# 数据结构和算法

## 数据结构

程序 = 数据结构 + 算法



### 线性结构和非线性结构

数据结构包括：线性结构和非线性结构

**线性结构**

1. 线性结构作为最常用的数据结构，其特点是**数据元素之间存在一对一**的线性关系（比如说数组）
2. 线性结构有两种不同的存储结构，即顺序存储结构（数组）和链式存储结构（链表）。顺序存储的线性表称为顺序表，顺序表中的存储元素（地址）是连续的。
3. 链式存储的线性表称为链表，链表中的存储元素（地址）不一定是连续的，元素结点中存放数据元素以及相邻元素的地址信息。
4. 线性结构常见的有：数组、队列、链表和栈

**非线性结构**

非线性结构包括：二维数组，多维数组，广义表，树结构，图结构



### 稀疏sparsearray数组

![image-20210508191334117](/Users/mac/Library/Application Support/typora-user-images/image-20210508191334117.png)



**稀疏数组**	

​	当数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。

**稀疏数组的处理方法是**

1. 记录数组中一共有几行几列，有多少个不同的值
2. 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模。

![image-20210508191803439](/Users/mac/Library/Application Support/typora-user-images/image-20210508191803439.png)

原始的：6行7列  6 x 7 = 42

稀疏数组：9 x 3 = 27(压缩了)

​	第一行：记录有几行几列几个不同的值

​	其余的：记录每一个非零的元素的行列和数据大小



**实际例子**

![image-20210508193322783](/Users/mac/Library/Application Support/typora-user-images/image-20210508193322783.png)

**二维数组转稀疏数组的思路**：

1. 遍历原始二维数组，得到有效数据的个数sum
2. 根据sum就可以创建稀疏数组sparseArr int[sum + ]\[3]
3. 将二维数组的有效数据存入稀疏数组中

**稀疏数组转原始二维数组的思路**

1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的chessArr = int[11] [11]
2. 再读取稀疏数组后几行的数据，并赋给原始的二维数组即可。

**代码实现**

一、原始二维数据转稀疏数组

```java
public class SparseArray {
    public static void main(String[] args) {
        //创建一个原始的二维数组 11 * 11
        //0:表示没有棋子， 1表示黑子 2表示蓝字
        int chessArr1[][] = new int[11][11];
        chessArr1[1][2] = 1;
        chessArr1[2][3] = 2;
        //输出原始的二维数组
        System.out.println("原始的二维数组");
        for(int[] row : chessArr1){
            for(int data:row){
                System.out.printf("%d\t",data);
            }
            System.out.println();
        }

        //将二维数组转换成稀疏数组
        //1、先遍历二维数组，得到非零的数字个数
        int sum = 0;
        for (int i = 0; i < chessArr1.length;i++){
            for (int j = 0;j < chessArr1[0].length;j++){
               if (chessArr1[i][j] != 0){
                   sum++;
               }
            }
        }
        System.out.println("sum = " + sum);

        //创建对应的稀疏数组
        int sparseArr[][] = new int[sum+1][3];
        //将二维数组的有效数据存入稀疏数组中
        //第一行要存行，列，非零值
        sparseArr[0][0] = chessArr1.length;
        sparseArr[0][1] = chessArr1[0].length;
        sparseArr[0][2] = sum;

        int m = 1;
        //找出非零数组是第几行第几列，值是多少
        for (int i = 0; i < chessArr1.length;i++){
            for (int j = 0;j < chessArr1[0].length;j++){
                if (chessArr1[i][j] != 0){
                    sparseArr[m][0] = i;
                    sparseArr[m][1] = j;
                    sparseArr[m][2] = chessArr1[i][j];
                    m++;
                }
            }
        }
        //输出稀疏数组
        System.out.println("稀疏数组为：");
//        for (int i = 0; i < sparseArr.length; i++){
//            for (int j =0; j< sparseArr[0].length; j++){
//                System.out.printf("%d\t",sparseArr[i][j]);
//            }
//            System.out.println();
//        }
        for (int[] row : sparseArr){
            for (int data : row){
                System.out.printf("%d\t",data);
            }
            System.out.println();
        }

    }
}
```

二、将稀疏数组转换成二维数组

```java
int row = sparseArr[0][0];
 int col = sparseArr[0][1];
 int chessArr2[][] = new int[row][col];

 //开始往里面放数据
 for (int h = 1; h < sparseArr[0].length;h++){
     int r = sparseArr[h][0];
     int c = sparseArr[h][1];
     chessArr2[r][c] = sparseArr[h][2];
 }
//遍历二维数组
 System.out.println("----------稀疏数组转化为二维数组----------");
 for (int[] row3 : chessArr2){
     for (int data2 : row3){
         System.out.printf("%d\t",data2);
     }
     System.out.println();
 }
```





### 队列

1. 队列是一个有序列表，可以用数组或是链表来实现
2. 遵循**先进先出**的原则。即：先存入队列的数据，要先取出，后存入的要后取出。
3. 示意图![image-20210508232623457](/Users/mac/Library/Application Support/typora-user-images/image-20210508232623457.png)
4. 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如上图，其中maxSize是该队列的最大容量。
5. 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量front和rear分别记录队列前后端的下标，front会随着数据的输出而改变，而rear会随着数据的输入而改变。



**数组模拟队列**

当我们将数据存储队列时称为“addQueue”,addQueue的处理需要两个步骤，**思路分析**：

1. 将尾指针往后移：rear+1  (条件是front == rear--->空)
2. 若尾指针rear小于队列的最大下标maxSize-1，则将数据存入rear所指的数组元素中，否组无法存入数据。rear == maxSize -1（队列满）



**代码实现**

```java
public class ArrayQueueDemo {
    public static void main(String[] args) {
        //测试
        //创建一个队列
        ArrayQueue queue = new ArrayQueue(3);
        char key = ' ';//接收用户输入
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        //输出一个菜单
        while (loop){
            System.out.println("s(show)：显示队列");
            System.out.println("e(exit)：退出队列");
            System.out.println("a(add)：添加数据到队列");
            System.out.println("g(get)：从队列取出数据");
            System.out.println("h(head)：查看队列头数据");
            key = scanner.next().charAt(0);//接收一个字符
            switch (key){
                case 's':
                    queue.showQueue();
                    break;
                case 'a':
                    System.out.println("输出一个数");
                    int value = scanner.nextInt();
                    queue.addQueue(value);
                    break;
                case 'g':
                    try{
                        int res = queue.getQueue();
                        System.out.printf("取出的数据是%d\n",res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h':   //查看队列头的数据是什么？
                    try{
                        int res = queue.headQueue();
                        System.out.printf("取出队列头的数据是%d\n",res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e':
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出！");
    }

}
class ArrayQueue{
    private int maxSize;//表示队列的最大容量
    private int front;//指向队列头部的前一个位置
    private int rear;//指向队列的尾部，就是最后一个数据的位置
    private int[] arr;//用于存放数据，模拟队列

    //创建一个队列构造器
    public ArrayQueue(int arrMaxSize){
        maxSize = arrMaxSize;
        arr = new int[maxSize];
        front = -1;
        rear = -1;
    }

    //判断队列是否满了
    public boolean isFull(){
        return rear == maxSize -1;
    }
    //判断队列是否为空
    public boolean isEmpty(){
        return rear == front;
    }
    //向队列中添加数据
    public void addQueue(int n){
        if (isFull()){
            System.out.println("队列已经满了，无法添加");
            return;
        }
        rear++;
        arr[rear] = n;
    }
    //从队列中取出数据
    public int getQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列空，不能取数据");
        }
        front++;
        return arr[front];
    }

    //显示队列的所有数据
    public void showQueue(){
        if(isEmpty()){
            System.out.println("队列是空的，没有数据！");
            return;
        }
       for (int i =0;i < arr.length;i++){
           System.out.printf("arr[%d]=%d\n",i,arr[i]);
       }
    }
    //显示队列的头部数据，注意不是取数据
    public int headQueue(){
        //判断是不是空
        if(isEmpty()){
            throw new RuntimeException("队列是空的，没有数据！");
        }
        return arr[front+1];
    }
}
```



**数组模拟环形队列**

思路分析：

1. front变量的含义做一个调整：front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素。front的初始值 = 0
2. rear变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间做出一个约定。rear的初试值 = 0；
3. 当队列满时，条件是（rear + 1） % maxSize == front(满)
4. 当队列为空的条件，rear == front 为空
5. 当我们这样分析，队列中有效数据的个数  (rear + maxSize - front) % maxSize  //rear = 1 front = 0
6. 在原来的代码基础上修改就可以得到环形队列



**代码实现**

```java
public class CircleArrayQueueDemo {
    public static void main(String[] args) {
        System.out.println("测试环形数组！");
        CircleArray queue = new CircleArray(4);//说明设置4，其队列的有效数据最大是3
        char key = ' ';//接收用户输入
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        //输出一个菜单
        while (loop){
            System.out.println("s(show)：显示队列");
            System.out.println("e(exit)：退出队列");
            System.out.println("a(add)：添加数据到队列");
            System.out.println("g(get)：从队列取出数据");
            System.out.println("h(head)：查看队列头数据");
            key = scanner.next().charAt(0);//接收一个字符
            switch (key){
                case 's':
                    queue.showQueue();
                    break;
                case 'a':
                    System.out.println("输入一个数");
                    int value = scanner.nextInt();
                    queue.addQueue(value);
                    break;
                case 'g':
                    try{
                        int res = queue.getQueue();
                        System.out.printf("取出的数据是%d\n",res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h':   //查看队列头的数据是什么？
                    try{
                        int res = queue.headQueue();
                        System.out.printf("取出队列头的数据是%d\n",res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e':
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出！");
    }

}
class CircleArray{
    private int maxSize;
    private int front;
    //front变量的含义做一个调整：front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素。front的初始值 = 0
    private int rear;
    //rear变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间做出一个约定。rear的初试值 = 0；
    private int[] arr;//存放数据

    public CircleArray(int arrMaxSize){
        maxSize = arrMaxSize;
        arr = new int[maxSize];
    }

    //判断队列是否满了
    public boolean isFull(){
        return (rear + 1) % maxSize == front;
    }

    //判断是不是为空
    public boolean isEmpty(){
        return rear == front;
    }
    //添加数据到队列
    public void addQueue(int n){
        //判断队列是否满
        if (isFull()){
            System.out.println("队列已满，不能加数据！");
            return;
        }
        //直接将数据加入
        arr[rear] = n;  //rear初始值就是0
        rear = (rear + 1) % maxSize;
    }
    //取出数据
    public int getQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列空，不能取数据!");
        }
        //这里需要先分析出front是指向队列的第一个元素
        //1、先把front对应的值保留到一个临时变量
        //2、将front后移,考虑取模
        //3、将临时保存的变量返回
        int value = arr[front];
        front = (front + 1) % maxSize;
        return value;
    }
    //显示队列数据
    public void showQueue(){
        if(isEmpty()){
            throw new RuntimeException("队列空，不能取数据!");
        }
        //思路：从front开始遍历，遍历多少个元素
        for(int i = front; i < front + size();i++){
            System.out.printf("arr[%d]=%d\n",i % maxSize,arr[i % maxSize]);
        }
    }

    //求出当前数组的有效数据的大小
    public int size(){
        return (rear + maxSize - front) % maxSize;
    }

    //把头元素打出来
    public int headQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列空，没有数据！");
        }
        return arr[front];
    }
}
```





### 链表（Linked List）

链表是有序的列表，但是它在内存中是存储如下：链式存储的，每一个结点并不是连续存储的

![image-20210510110116870](/Users/mac/Library/Application Support/typora-user-images/image-20210510110116870.png)

小结：

1. 链表是以结点的方式来存储的，链式存储的。
2. 每个结点包含data域，next域：指向下一个结点。
3. 如图：发现链表的各个结点不一定是连续存储的（指的是地址不一定是连续的）
4. 链表分为：带头结点的链表和没有头结点的链表，根据实际的需求来确定。



单链表（带头结点）逻辑结构示意图如下：

![image-20210510110824066](/Users/mac/Library/Application Support/typora-user-images/image-20210510110824066.png)



单链表的创建（添加）示意图，显示单向链表的分析：

添加（创建）：

1. 先创建一个head头结点，作用就是表示单链表的头
2. 后面我们每添加一个结点，就直接加入到链表的最后

遍历：

1. 通过一个辅助变量，帮助遍历整个单链表



**需要按照编号的顺序添加**

1. 首先找到新添加结点的位置，是通过辅助变量（指针），通过遍历搞定
2. 新的结点.next = temp.next
3. 将temp.next = 新的结点

**删除结点**

1. 我们先找到要删除结点的前一个结点temp
2. temp.next = temp.next.next
3. 被删除的结点，将不会有其他引用指向，会被垃圾回收机制回收。

**代码实现**

```java
public class SingleLinkedListDemo {
    public static void main(String[] args) {
        HeroNode hero1 = new HeroNode(1,"宋江","及时雨");
        HeroNode hero2 = new HeroNode(2,"卢俊义","玉麒麟");
        HeroNode hero3 = new HeroNode(3,"吴用","智多星");
        HeroNode hero4 = new HeroNode(4,"林冲","豹子头");
        //创建单向链表
        SingleLinkedList singleLinkedList = new SingleLinkedList();
        //加入
//        singleLinkedList.add(hero1);
//        singleLinkedList.add(hero2);
//        singleLinkedList.add(hero3);
//        singleLinkedList.add(hero4);

        //第二种加入
        singleLinkedList.addByOrder(hero1);
        singleLinkedList.addByOrder(hero4);
        singleLinkedList.addByOrder(hero3);
        singleLinkedList.addByOrder(hero2);
        //显示一下
        singleLinkedList.list();

        System.out.println("----------------修改过后的结果----------------");
        HeroNode newHero = new HeroNode(9, "小卢", "玉麒麟~~");
        singleLinkedList.update(newHero);
        singleLinkedList.list();

        singleLinkedList.delete(1);
        singleLinkedList.delete(4);
        singleLinkedList.delete(2);
        singleLinkedList.delete(3);
        System.out.println("----------------修改过后的结果----------------");
        singleLinkedList.list();

    }

}

//创建一个LinkedList链表
class SingleLinkedList{
    //先初始化一个头结点，头结点不要动,不存放具体的数据
    private HeroNode head = new HeroNode(0,"","");

    //添加的方法,添加结点到单向链表中
    //思路：当不考虑编号的顺序时
    //找到当前链表的最后一个结点
    //将最后一个结点的next指向新的结点
    public void add(HeroNode heroNode){
        //因为head结点不能动，因此需要一个辅助变量temp
        HeroNode temp = head;
        //遍历链表，找到最后一个结点
        while (true){
            //最后一个结点
            if (temp.next == null){
                break;
            }
            //如果没有找到最后,temp往后移
            temp = temp.next;
        }
        //当退出循环的时候，temp就指向链表的最后了
        temp.next = heroNode;
    }

    //第二种添加方式，根据排名插入到指定的位置
    public void addByOrder(HeroNode heroNode){
        //因为头结点不能动，因此通过一个辅助指针来帮助找到位置
        //因为单链表，我们找到的temp是位于添加位置的前一个结点，否则插入不了
        HeroNode temp = head;
        boolean flag = false;//flag表示添加的编号是否存在，默认为false
        while (true){
            if (temp.next == null){//最后一个结点了
                break;
            }
            if (temp.next.no > heroNode.no){//位置找到
                break;
            }else if (temp.next.no == heroNode.no){//说明希望添加的编号已经存在了
            flag = true;//说明编号存在了
            break;
            }
            temp = temp.next;//后移，遍历当前链表
        }
        //判断flag
        if (flag){
            System.out.printf("当添加的编号%d以及存在，添加失败\n",heroNode.no);
        }else {//插入到链表当中，temp后面
            heroNode.next = temp.next;
            temp.next = heroNode;
        }

    }

    //修改结点的信息，根据no编号来修改，即no不能变
    public void update(HeroNode newHeroNode){
        //判断是否为空
        if(head.next == null){
            System.out.println("链表为空！");
        }
        //找到需要修改的结点，根据no编号
        //定义一个辅助变量
        HeroNode temp = head.next;
        boolean flag = false;//表示是否找到该结点
        while (true){
            if (temp == null){
                //已经遍历完链表了
                break;
            }
            if (temp.no == newHeroNode.no){//找到了
                flag = true;
                break;
            }
            temp = temp.next;
        }
        //判断找到没有
        if(flag){
            temp.name = newHeroNode.name;
            temp.nickName = newHeroNode.nickName;
        }else {
            System.out.printf("没有找到编号%d的结点信息\n",newHeroNode.no);
        }
    }

    //删除结点
    //head结点不能动
    public void delete(int no){
        HeroNode temp = head;
        //判断链式是不是空的


        boolean flag = false;
        while (true){
            if (temp.next == null){
                System.out.println("链表到最后了，不能删除!");
                break;
            }
            if(temp.next.no == no){//找到了
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag){
            temp.next = temp.next.next;
        }else {
            System.out.printf("要删除的%d结点不存在",no);
        }
    }

    //显示链表，遍历
    public void list(){
        if (head.next == null){//判断链表是否为空
            System.out.println("链表为空！");
        }
        //头结点不能动,因此需要一个辅助结点来遍历
        HeroNode temp = head.next;
        while (true){
            if (temp == null){
                break;
            }
            //输出结点的信息
            System.out.println(temp);
            temp = temp.next;
        }

    }

}
class HeroNode{
    //基本属性
    public int no;
    public String name;
    public String nickName;
    public HeroNode next;
    //构造器
    public HeroNode(int hNo, String hName, String hNickName){
        this.no = hNo;
        this.name = hName;
        this.nickName = hNickName;
    }
    //重写toString方法
    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickName='" + nickName + '\'' +
                '}';
    }
}
```

 **单链表面试题（新浪，百度，腾讯）**

单链表的常见面试题有如下：

1. 求单链表中的有效结点的个数

   ```java
   public static int getLength(HeroNode head){
       if (head.next == null){
           //这是一个空结点
           return 0;
       }
       int length = 0;
       HeroNode temp = head.next;
       while (temp != null){
           length++;
           temp = temp.next;
       }
       return length;
   }
   ```

2. 查找单链表中的倒数第k个结点（新浪）

   ```java
   public static HeroNode findLastIndexHero(HeroNode head,int index){
       if (head.next == null){
           System.out.println("链表为空，无法查找");
       }
       HeroNode temp = head.next;
       //先找到一共几个结点
       int k = 1;
       while (temp != null){
           temp = temp.next;
           k++;
       }
       //先做一个数据的校验
       if (index <= 0 ||index > k){
           return null;
       }
       //找出正数的第（k-index）结点就是要找的
       int m = 1;
       HeroNode temp1 = head.next;
       while (m != (k-index)){
           temp1 = temp1.next;
           m++;
       }
       return temp1;
   }
   ```

3. 单链表的反转（腾讯）

   思路分析：

   1. 先定义一个新的结点reverseHead = new HeroNode();

   2. 从头到尾遍历原理的链表，每遍历一个结点，就将其取出，并放在新的链表的最前端。

   3. 把head结点指向最后加入的那个结点。head.next = reverseHead.next

      ```java
      //单链表的反转（腾讯）
      public static void reverseLinkedList(HeroNode head){
          if(head.next == null|| head.next.next == null){
              System.out.println("无需反转");
              return;
          }
          //定义一个辅助的指针，帮助遍历原来的链表
          HeroNode curr = head.next;
          HeroNode next = null;//指向当前结点的下一个结点
          //先创建一个新的链表
          HeroNode reverseHead = new HeroNode(0,"","");
          //遍历传进来的链表，每取出来一个就把它放到新链表的最前面
          while (curr != null){
              next = curr.next;//先暂时保留当前结点的下一个结点
              curr.next = reverseHead.next;
              reverseHead.next = curr;    //将curr加到新的链表上
              curr = next;
          }
          //将head.next指向reverseHead.next
          head.next = reverseHead.next;
      }
      ```

4. 从尾到头打印单链表（百度：要求方式1：反向遍历。方式2：Stack栈）

   思路分析：

   1. 上面的题目要求，就是逆序打印单链表

   2. 方式1：现将单链表反转，然后遍历即可，这样做的问题是：会破坏原来单链表的结构，不建议这样操作。

   3. 方式2：利用栈这个数据结构，将各个结点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果。使用stack集合

      ```java
      public static void reversePrint(HeroNode head){
          if (head.next == null){
              return;
          }
          Stack<HeroNode> stack = new Stack<HeroNode>();
          HeroNode cur = head.next;
          //将链表的所有结点压如栈中
          while (cur != null){
              stack.push(cur);
              cur = cur.next;
          }
          while (stack.size() > 0){
              System.out.println(stack.pop());
          }
      }
      ```

5. 合并两个有序的单链表，合并之后的单链表依然有序。

   思路分析：

   首先分析合并两个链表的过程。我们的分析从合并两个链表的头结点开始。链表1的头结点的值小于链表2的头结点的值，因此链表1的头结点将是合并后链表的头结点，如图所示：

   

![这里写图片描述](https://img-blog.csdn.net/20150801211838520?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

我们继续合并两个链表中剩余的结点。在两个链表中剩下的结点依然是排序的，因此合并这两个链表的步骤和前面的步骤是一样的。我们还是比较两个头结点的值。此时链表2的头结点的值小于链表1的头结点的值，因此链表2的头结点的值将是合并剩余结点得到的链表的头结点。我们把这个结点和前面合并链表时得到的链表的尾结点链接起来，如图所示。
当我们得到两个链表中值较小的头结点并把它链接到已经合并的链表之后，两个链表剩余的结点依然是排序的，因此合并的步骤和之前的步骤是一样的。这就是典型的递归的过程。

**代码实现**

```java
public static HeroNode mergeLists(HeroNode list1,HeroNode list2){
    if (list1 == null){
        return list2;
    }else if(list2 == null){
        return list1;
    }

    HeroNode newHead = null;
    if (list1.no < list2.no){
        newHead = list1;
        newHead.next = mergeLists(list1.next,list2);
    }else {
        newHead = list2;
        newHead.next = mergeLists(list2.next,list1);
    }
    return newHead;
}
```



### 双向链表

单向链表的缺点：

1. 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。
2. 单向链表不能自我删除，需要依靠辅助结点，而双向链表，则可以自我删除，所以前面单向链表删除结点时，总是找到temp，temp是待删除结点的前一个结点。

**分析双向链表的遍历，添加，删除的操作思路**

![image-20210511211055931](/Users/mac/Library/Application Support/typora-user-images/image-20210511211055931.png)

1. 遍历和单向链表一样，只是可以向前，也可以向后查找
2. 添加（默认加到双向链表的最后）
   1. 先找到双向链表的最后一个结点
   2. temp.next = newHeroNode
   3. newHeroNode.pre = temp
3. 修改和单向链表的思路一样
4. 删除
   1. 因为是双向链表，因此，可以实现自我删除某个结点
   2. 直接找到要删除的结点，比如temp
   3. temp.pre.next = temp.next
   4. temp.next.pre = temp.pre

### 单向环形链表应用场景(约瑟夫问题)

Josephu（约瑟夫环，约瑟夫环）问题

![image-20210512164740257](/Users/mac/Library/Application Support/typora-user-images/image-20210512164740257.png)

​													丢手绢问题

Josephu问题为：设编号为1,2,...,n的n个人围坐在一圈，约定编号为k（1<=k<=n）的人从1开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，以此类推，直到所有人出列为止，有此产生一个出队编号的序列。

**提示**：用一个不带头结点的循环链表来处理Josephu问题，先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中被删除，算法结束。



**单向环形链表**

![image-20210512164905850](/Users/mac/Library/Application Support/typora-user-images/image-20210512164905850.png)

**约瑟夫问题示意图**

设：n = 5 ，即有五个人

​		k = 1,从第一个人开始报数

​		m = 2,数两下

![image-20210512165342194](/Users/mac/Library/Application Support/typora-user-images/image-20210512165342194.png)

出圈的顺序推演为：2->4->1->-5->3

**构建一个单向环形链表的思路**

1. 先创建第一个结点，让first指向该结点，并形成环形
2. 后面当我们每创建一个新的结点，就把该结点，加入到已有的环形链表中即可。

**遍历**

1. 先让一个辅助指针（变量），指向first结点
2. 然后通过一个while循环遍历环形链表即可，currBoy.next = first结束

**约瑟夫问题的实现**

1. 需要创建一个辅助指针（变量）helper，事先应该指向环形链表的最后这个结点
2. 报数前，先让first和helper移动k-1次，就是移动到k那个位置
3. 当小孩报数的前，让first和helper指针同时移动m-1次
4. 这时就可以将first指向的小孩结点出圈  first = first.next    helper.next = first 原来first指向的结点就没有任何引用，就会被回收。

**代码实现**

```java
/**
 * @param startNo  表示从第几个小孩开始数
 * @param countNum 表示数几下
 * @param nums     表示最初有多少小孩在圈中
 */
public void countBoy(int startNo, int countNum, int nums) {
    //数据校验
    if (first == null || startNo < 1 || startNo > nums) {
        System.out.println("数据输入有误，请重新输入！");
        return;//直接退出不玩了
    }
    //先创建一个辅助指针,放到first后面
    Boy helper = first;
    while (true) {
        if (helper.getNext() == first) {//说明helper指向最后小孩结点
            break;
        }
        helper = helper.getNext();
    }
    //小孩报数前，先让helper和first移动到要报数的地方,移动startNo -1 下
    for (int i = 0; i < startNo - 1; i++) {
        first = first.getNext();
        helper = helper.getNext();
    }
    //退出循环的时候，说明已经到达地方了
    //开始报数，移动countNum - 1 次，出圈
    while (true) {
        if (helper == first) {//说明已经到最后，剩下一个小孩了
            break;
        }
        for (int j = 0; j < countNum - 1; j++) {
            first = first.getNext();
            helper = helper.getNext();
        }
        //退出遍历，说明找到地方了，现在让小孩出圈
        System.out.printf("第%d个小孩出圈\n", first.getNo());
        //出圈
        first = first.getNext();
        helper.setNext(first);
    }
    //退出循环的时候，说明圈子里还剩下最后一个小孩
    System.out.printf("最后一个小孩%d还在圈中", helper.getNo());
}
```



### 栈(Stack)

栈的实际需求：

请输入一个表达式：计算式：7 * 7 * 7 - 5 + 1 -5 +3 -3 点击计算

请问：计算机底层是如何运算得到结果的？注意不是简单的把算式列出运算，因为对计算机而言，它接收到的就是一个字符串。String str = "7 * 7 * 7 - 5 + 1 -5 +3 -3 "

**栈的介绍**

1. 栈的英文是stack

2. 栈是一个先进后出的有序列表

3. 栈是限制线性表中元素插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶（Top），另一端固定的一端，称为栈底（Bottom）.

4. 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除。

5. 出栈(pop)和入栈(push)的概念

   **栈的应用场景**

   1. 子程序调用：在跳往子程序前，会先将下一个指令的地址放入堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。
   2. 处理递归调用：和子程序调用类似，只是除了存储下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。
   3. 表达式的转换（中缀表达式转后缀表达式）与求值（实际解决）
   4. 二叉树的遍历
   5. 图形的深度优先（depth-first）搜索法

**数组模拟栈的思路分析**

1. 使用数字模拟栈
2. 定义一个变量top表示栈顶，初始化为-1
3. 入栈的操作，当有数据加入到栈的时候，top++，stack[top] = data;
4. 出栈的操作，int value = stack[top];top--,return value;

**代码实现**

```java
//定义一个ArrayStack 表示栈
class ArrayStack {
    private int maxSize;//栈的大小
    private int[] stack;//数组，模拟栈
    private int top = -1;//表示栈顶，初始化为-1
    //构造器
    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }
    //判断栈满
    public boolean isFull() {
        return top == maxSize - 1;
    }
    //判断栈空
    public boolean isEmpty() {
        return top == -1;
    }
    //入栈
    public void push(int value) {
        if (isFull()) {
            System.out.println("栈已满，无法入栈！");
            return;
        }
        top++;
        stack[top] = value;
    }
    //出栈
    public int pop() {
        if (isEmpty()) {
            throw new RuntimeException("栈为空，无法出栈！");
        }
        int value = stack[top];
        top--;
        return value;
    }
    //显示栈的情况（遍历栈）
    public void list() {
        if (isEmpty()) {
            System.out.println("栈空，没有数据！");
            return;
        }
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d] = %d\n", i, stack[i]);
        }
    }
}
```



**链表模拟**

**栈实现综合计算器**

使用栈完成表达式计算的思路

![image-20210519192704545](/Users/mac/Library/Application Support/typora-user-images/image-20210519192704545.png)

1. 通过一个index值（索引），来遍历我们的表达式

2. 如果我们发现是一个数字，就直接入数栈

3. 如果发现扫描到的是一个符号，就分如下情况解决

   3.1如果发现当前的符号栈为空，就直接入栈

   3.2如果符号栈有操作符，就进行比较，**如果当前的操作符的优先级小于或者等于栈中的操作符**，就需要从数栈中pop出两个数，在符号栈中pop出一个符号，进行运算，将得到的结果，入数栈，然后将当前的操作符入符号栈。**如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈**

4. 当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行

5. 最后在数栈中只有一个数字，就是表达式的结果

**代码实现**

```java
public class Calculator {
    public static void main(String[] args) {
        //完成表达式的运算
        String expression = "90+2*6-2";
        //创建两个栈，一个数栈，一个符号栈
        ArrayStack2 numStack = new ArrayStack2(10);
        ArrayStack2 operStack = new ArrayStack2(10);
        //初始化遍历
        int index = 0;
        int num1 = 0;
        int num2 = 0;
        int res = 0;
        int oper = 0;
        char ch = ' ';//将每次扫描得到的char保存到ch
        String keepNum = "";
        //开始while循环的扫描expression
        while (true) {
            //依次得到每一个字符
            ch = expression.substring(index, index + 1).charAt(0);
            //判断ch是什么数还是符号
            if (operStack.isOper(ch)) {//如果是符号的话，分两种情况入栈
                if (!operStack.isEmpty()) {
                    if (operStack.priority(ch) <= operStack.priority(operStack.peak())) {
                        num1 = numStack.pop();
                        num2 = numStack.pop();
                        oper = operStack.pop();
                        res = operStack.cal(num1, num2, oper);
                        //将得到的结果，入数栈，然后将当前的操作符入符号栈。
                        numStack.push(res);
                        operStack.push(ch);
                    } else {
                        operStack.push(ch);
                    }
                } else {//如果当前符号栈是空的，直接入栈
                    operStack.push(ch);

                }
            } else {//是数字，直接入栈
//                numStack.push(ch - 48);
                //分析思路:
                //1.当处理多位数的时候，不能发现一个数就立即入栈，因为他可能是多位数
                //2、在处理数，需要向expression表达式的index后再看一位，如果是数就进行扫描，如果是符号才入栈
                //3、因此我们需要定义一个变量字符串，用于拼接
                keepNum += ch;
                //判断是不是到最后一位了
                if (index == expression.length() - 1) {
                    numStack.push(Integer.parseInt(keepNum));
                }else {
                    if (operStack.isOper(expression.substring(index+1,index+2).charAt(0))){
                        //如果最后一位是运算符，则入栈keepNum = "1" 或者"123"
                        numStack.push(Integer.parseInt(keepNum));
                        keepNum = "";
                    }
                }


            }
            index++;
            if (index >= expression.length()) {
                break;
            }
        }
        //表达式扫描完毕，顺序的从数栈和符号栈中pop出相应的数字和符号，并运行
        while (true) {
            if (operStack.isEmpty()) {
                //如果符号栈为空，说明计算结束了
                break;
            }
            num1 = numStack.pop();
            num2 = numStack.pop();
            oper = operStack.pop();
            res = operStack.cal(num1, num2, oper);
            numStack.push(res);
        }
        //打印结果
        System.out.printf("表达式 %s = %d", expression, numStack.pop());


    }
}

class ArrayStack2 {
    private int maxSize;//栈的大小
    private int[] stack;//数组，模拟栈
    private int top = -1;//表示栈顶，初始化为-1

    //构造器
    public ArrayStack2(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }

    //返回当前栈顶值，但不是真正的pop
    public int peak() {
        return stack[top];
    }

    //判断栈满
    public boolean isFull() {
        return top == maxSize - 1;
    }

    //判断栈空
    public boolean isEmpty() {
        return top == -1;
    }

    //入栈
    public void push(int value) {
        if (isFull()) {
            System.out.println("栈已满，无法入栈！");
            return;
        }
        top++;
        stack[top] = value;
    }

    //出栈
    public int pop() {
        if (isEmpty()) {
            throw new RuntimeException("栈为空，无法出栈！");
        }
        int value = stack[top];
        top--;
        return value;
    }

    //显示栈的情况（遍历栈）
    public void list() {
        if (isEmpty()) {
            System.out.println("栈空，没有数据！");
            return;
        }
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d] = %d\n", i, stack[i]);
        }
    }

    //返回运算符的优先级，优先级是程序员定的，优先级使用数字表示
    //数字越大，则优先级就越高
    public int priority(int oper) {
        if (oper == '*' || oper == '/') {
            return 1;
        } else if (oper == '+' || oper == '-') {
            return 0;
        } else {
            return -1;
        }
    }

    //判断是不是运算符
    public boolean isOper(char val) {
        return val == '+' || val == '-' || val == '*' || val == '/';
    }

    //计算方法
    public int cal(int num1, int num2, int oper) {
        //假定结果返回的是res
        int res = 0;
        switch (oper) {
            case '+':
                res = num1 + num2;
                break;
            case '-':
                res = num2 - num1;
                break;
            case '*':
                res = num1 * num2;
                break;
            case '/':
                res = num2 / num1;
                break;
            default:
                break;
        }
        return res;
    }
}
```





**前缀、中缀、后缀表达式（逆波兰表达式）**

**前缀表达式**（逆波兰表达式）

1. 前缀表达式又称为波兰表达式，前缀表达式的运算符位于操作数之前
2. 举例说明：(3+4)*5-6对应的前缀表达式就是    - x + 3 4 5 6

前缀表达式的计算机求值

从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对他们做相应的计算（栈顶元素和次顶元素），并将结果入栈；重读上述过程直到表达式最左端，最后原酸得出的值即为表达式的结果

例如：(3+4)*5-6对应的前缀表达式就是- x + 3 4 5 6，针对前缀表达式求值的步骤如下：

1. 从右至左扫描，将6、5、4、3压入堆栈
2. 遇到加运算符，因此弹出3和4（3位栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈
3. 接下来是*运算符，因此弹出7和5，计算出7*x5=35，将35入栈
4. 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。



**中缀表达式**

1. 中缀表达式就是常见的运算表达式，
2. 中缀表达式是人类熟悉的，但是计算机不熟悉的



**后缀表达式**

1. 后缀表达式又称为逆波兰表达式，与前缀表达式相似，只是运算符位于操作数之后
2. 举例说明 (3+4)*5-6 对应的后缀表达式就是 3 4  + 5 * 6 -
3. 再比如：

![image-20210520150255760](/Users/mac/Library/Application Support/typora-user-images/image-20210520150255760.png)

后缀表达式的计算机求值

从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做出相应的计算（次顶元素和栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果



例如：(3+4)*5-6 对应的后缀表达式就是3 4 + 5 x 6 -，针对后缀表达式求值步骤如下：

1. 从左至右扫描，将对应3和4压入堆栈
2. 遇到+运算符，因此弹出4和3（4位栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
3. 将5入栈
4. 接下来是x运算符，因此弹出5和7，计算出7 x 5 = 35，将35入栈
5. 将6入栈
6. 最后是-运算符，计算出35-6的值，即29，由此得出最终结果



**逆波兰计算器**

我们完成一个逆波兰计算器，要求完成如下任务

1. 输入一个逆波兰表达式，谁用栈（Stack）计算出结果
2. 支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算
3. 思路分析
4. 代码完成

**代码实现**

```java
public class PolandNotation {
    public static void main(String[] args) {
        //先定义一个逆波兰表达式
        //(3+4)*5-6
//        String suffixExpression = "3 4 + 5 * 6 -";
        //(30+4)*5-6 = 164
        String suffixExpression = "30 4 + 5 * 6 -";
        //测试一把转换
        List<String> res = getListString(suffixExpression);
        System.out.println(res);

        int val = calculator(res);
        System.out.println("计算的结果是：" + val);

    }

    //将一个逆波兰表达式，依次将数据和运算符放入到ArrayList中
public static List<String> getListString(String suffixExpression){
        //先用正则表达式分割字符串
    String[] split = suffixExpression.split(" ");
    ArrayList<String> list = new ArrayList<>();
    //把字符串放到一个ArrayList中
    for (String ele:split){
        list.add(ele);
    }
    return list;
}

    //完成对波兰表达式计算
    /**
     1. 从左至右扫描，将对应3和4压入堆栈
     2. 遇到+运算符，因此弹出4和3（4位栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
     3. 将5入栈
     4. 接下来是x运算符，因此弹出5和7，计算出7 x 5 = 35，将35入栈
     5. 将6入栈
     6. 最后是-运算符，计算出35-6的值，即29，由此得出最终结果
     */
    public static int calculator(List<String> list){
        //创建一个栈
        Stack<String> stack = new Stack<>();
        //遍历list
        for (String item:list){
            //这里使用正则表达式取数
            if(item.matches("\\d+")){//匹配的多位数
                //入栈
                stack.push(item);
            }else {
                //pop出两个数,并运算，再入栈
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int res = 0;
                //判断这里的运算符是什么
                if (item.equals("+")){
                    res = num1 + num2;
                }else if(item.equals("-")){
                    res = num1 - num2;
                }else if(item.equals("*")){
                    res = num1 * num2;
                }else if(item.equals("/")){
                    res = num1 / num2;
                }else {
                    throw new RuntimeException("您的输入有误，请重新输入！");
                }
                //将运算的结果压入栈中
                stack.push("" + res);
            }
        }
        return Integer.parseInt(stack.pop());
    }
}
```



**中缀转后缀表达式**

具体步骤如下：

1. 初始化两个栈：运算符栈s1和存储中间结果的栈s2
2. 从左至右扫描中缀表达式
3. 遇到操作数时，将其压入s2
4. 遇到运算符时，比较其与s1栈顶运算符的优先级：
   1. 如果s1为空，或栈顶运算符为左括号“（”，则直接将此运算符入栈；
   2. 否则，若优先级比栈顶运算符的高，也将运算符压入s1;
   3. 否则，将s1栈顶运算符弹出并压入到s2中，再次转到（4-1）与s1中新的栈顶运算符相比较；
5. 如果遇到括号时：
   1. 如果是左括号“（”，则直接压入s1
   2. 如果是右括号“）”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃。
6. 重复步骤2至5，直到表达式的最右边
7. 将s1中剩余的运算符依次弹出并压入s2
8. 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式。



举例：中缀表达式：1 + ( ( 2+3 ) ) x 4 - 5  ----->后缀表达式

![image-20210520205959196](/Users/mac/Library/Application Support/typora-user-images/image-20210520205959196.png)



**代码实现**

```java
public static List<String> parseSuffixExpression(List<String> ls) {
    //定义两个栈
    Stack<String> s1 = new Stack<String>();//符号栈
    ArrayList<String> s2 = new ArrayList<String>();//数栈
    //遍历传进来的List
    for (String item : ls) {
        if (item.matches("\\d+")) {//如果item是一个数加入s2
            s2.add(item);
        } else if (item.equals("(")) {//如果遇到的是左括号，直接压入s1
            s1.push(item);
        } else if (item.equals(")")) {//如果遇到的是右括号
            //则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
            while (!s1.peek().equals("(")) {
                s2.add(s1.pop());
            }
            s1.pop();
        } else {//如果遇到的是运算符，比较其于s1栈顶运算符的优先级
            while (s1.size() != 0 && Operation.getValue(s1.peek()) >= Operation.getValue(item)) {
                s2.add(s1.pop());
            }
            //还需要将item压入栈中
            s1.push(item);

        }

    }
    while (s1.size() != 0) {
        s2.add(s1.pop());
    }
    return s2;
}
```



### 哈希表

google一个上机题：

有一个公司，当有新员工来报道时，要求将该员工的信息加入（id,性别，年龄，住址），当输入该员工的id时，要求查找到该员工的所有信息



要求：不使用数据库，尽量节省内存，速度越快越好=>哈希表（散列）



**散列表**：（Hash table,也叫哈希表）是根据关键码值（Key Value）**而直接进行访问的数据结构**，也就是说，它通过把关键码值映射到一个表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做：**散列函数**，存放记录的数组叫做**散列表**

![image-20210607173143504](/Users/mac/Library/Application Support/typora-user-images/image-20210607173143504.png)



哈希表的结构：

![image-20210607173207338](/Users/mac/Library/Application Support/typora-user-images/image-20210607173207338.png)

![image-20210607190929232](/Users/mac/Library/Application Support/typora-user-images/image-20210607190929232.png)

哈希表里面放的是数组，数组里面的每一个元素是一个链表（头），指向的是雇员信息。



**代码实现**

```java
//编写HashTab 管理多条链表
class HashTab {
    private EmpLinkedList[] empLinkedListArray;
    private int size;

    public HashTab(int size) {
        this.empLinkedListArray = new EmpLinkedList[size];
        //这里不要忘了初始化每一条链表
        for (int i = 0; i < size; i++) {
            empLinkedListArray[i] = new EmpLinkedList();
        }
        this.size = size;
    }

    //遍历HashTab
    public void list() {
        for (int i = 0; i < size; i++) {
            empLinkedListArray[i].list(i);
        }
    }

    //添加元素的方法
    public void add(Emp emp) {
        int empLinkedListNo = hashFun(emp.id);
        empLinkedListArray[empLinkedListNo].add(emp);
    }

    //散列函数
    public int hashFun(int id) {
        return id % size;
    }

    //根据输入的id查找雇员
    public void findById(int id) {
        int empLinkedListNo = hashFun(id);
        Emp emp = empLinkedListArray[empLinkedListNo].findEmpById(id);
        if (emp != null) {//找到了
            System.out.printf("在第%d条链表中找到雇员 id = %d/n",empLinkedListNo + 1,id);
        }else {
            System.out.println("在哈希表中，没有找到该雇员");
        }
    }

}

//创建一个雇员
class Emp {
    public int id;
    public String name;
    public Emp next;

    public Emp(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

//创建一个EmpLinkedList
class EmpLinkedList {
    //头指针
    private Emp head;//默认为null

    //添加雇员方法
    public void add(Emp emp) {
        if (head == null) {
            head = emp;
            return;
        }
        //如果不是第一个雇员，遍历一下，找到最后一个结点，放到最后
        Emp temp = head;
        while (true) {
            if (temp.next == null) {//temp就是最后一个
                break;
            }
            temp = temp.next;
        }//退出的时候添加进去
        temp.next = emp;
    }

    //遍历链表
    public void list(int no) {
        if (head == null) {
            System.out.println("第" + (no + 1) + "条链表:");
            return;
        }
        Emp temp = head;
        System.out.print("第" + (no + 1) + "条链表信息为:");
        while (true) {
            System.out.printf("=> id = %d name = %s\t", temp.id, temp.name);
            if (temp.next == null) {
                break;
            }
            temp = temp.next;
        }
        System.out.println();
    }

    //查找雇员的方法
    public Emp findEmpById(int id) {
        //判断链表是否为空
        if (head == null) {
            System.out.println("链表为空！");
            return null;
        }
        //辅助指针
        Emp curEmp = head;
        while (true) {
            if (curEmp.id == id) {//找到了
                break;//这时curTemp就指向要查找的雇员
            }
            //退出
            if (curEmp.next == null) {//说明遍历完毕都没有找到该雇员
                curEmp = null;
                break;
            }
            curEmp = curEmp.next;
        }
        return curEmp;
    }
}
```



### 树结构（基础）

**为什么需要树结构**

1. 数组存储方式的分析

   优点：通过下标方式访问元素，速度快。**对于有序数组**，还可以使用二分查找提高检索速度。

   缺点：如果要检索具体某个值，或者插入值（按一定顺序）会整体移动，效率较低（实现分配好了空间，要数组扩容，在底层需要创建新的数组，要将原来的数据拷贝到新数组）

2. 链式存储方式的分析：

   优点：在一定程度上对数组存储方式有优化（比如：插入一个数值结点，只需要将插入结点，连接到链表中即可，删除效率也比较高）

3. 树存储方式的分析

   能提高数据存储，读取的效率，比如利用二叉树排序（Binary Sort Tree）,既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。

   缺点：在进行检索的时候，效率仍然较低，比如：检索某个值，需要从头结点开始遍历

   分析：如果以二叉排序树来存储数据，那么对数据的增删改查的效率都可以提高

   例如：[7,3,10,1,5,9,12]

   ![image-20210607213900576](/Users/mac/Library/Application Support/typora-user-images/image-20210607213900576.png)

分析一下二叉排序树来存储的效率

1、查找12，经过两次比较久找到12结点

2、添加，也很快

3、删除效率也很高

**树的常用术语**

1. 结点
2. 根结点
3. 父结点
4. 子结点
5. 叶子结点（没有子结点的结点）
6. 结点的权（结点值）
7. 路径（从根结点找到该结点的路线）
8. 层
9. 子树
10. 树的高度：最大层数
11. 森林：多颗子树构成森林

**二叉树**

1. 树有很多种，每个结点**最多只能有两个子结点**的一种形式成为二叉树
2. 二叉树的子结点分为左结点和右结点
3. 如果该二叉树的所有叶子结点都在最后一层，并且结点总数=2^n-1，n为层数，则我们称为满二叉树。
4. 如果该二叉树的所有叶子结点都在最后一层或者倒数第二层。而且最后一层的叶子结点在左边连续，倒数第二层的叶子结点在右边连续，我们称为完全二叉树。
5. ![image-20210608103248484](/Users/mac/Library/Application Support/typora-user-images/image-20210608103248484.png)





二叉树的遍历方式：

前序遍历：**先输出父结点**，再遍历左子树和右子树

中序遍历：先遍历左子树，**再输出父结点**，再遍历出父结点

后序遍历：先遍历左子树，再遍历右子树，**最后输出父结点**

**小结**：看输出父结点的顺序，就确定是前序，中序和后序

![image-20210608142357033](/Users/mac/Library/Application Support/typora-user-images/image-20210608142357033.png)



分析二叉树的前序，中序，后序的遍历步骤：

1. 创建一颗二叉树

2. 前序遍历：

   2.1先输出当前结点（初始的时候是根结点）

   2.2如果左子结点不为空，则递归继续前序遍历

   2.3如果右子结点不为空，则递归继续前序遍历

3. 中序遍历：

   3.1如果当前结点的左子结点不为空，则递归中序遍历，先输出当前结点（初始的时候是根结点）

   3.2输出当前结点

   3.3如果当前结点的右子结点不为空，则递归中序遍历

4. 后序遍历：

   4.1如果当前结点的左子结点不为空，则递归后序遍历

   4.2.如果当前结点的右子结点不为空，则递归后序遍历

   4.3输出当前结点



**代码实现**

```java
//先创建HeroNode结点
class HeroNode {
    private int no;
    private String name;
    private HeroNode left;
    private HeroNode right;

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }

    //编写前序遍历的方法
    public void preOrder() {
        System.out.println(this);//先输出父结点
        //递归向左子树前序遍历
        if (this.left != null) {
            this.left.preOrder();
        }
        //递归向右子树前序遍历
        if (this.right != null) {
            this.right.preOrder();
        }
    }

    //编写中序遍历的方法
    public void infixOrder() {
        //递归想左子树中序遍历
        if (this.left != null) {
            this.left.infixOrder();
        }
        //输出父结点
        System.out.println(this);
        //递归向右子树中序遍历
        if (this.right != null) {
            this.right.infixOrder();
        }
    }

    //编写后序遍历的方法
    public void postOrder() {
        //先向左子树递归后序遍历
        if (this.left != null) {
            this.left.postOrder();
        }
        //向右子树递归后序遍历
        if (this.right != null) {
            this.right.postOrder();
        }
        //输出当前结点
        System.out.println(this);

    }
}
```

```java
//定义一个二叉树
class BinaryTree {
    private HeroNode root;

    public void setRoot(HeroNode root) {
        this.root = root;
    }

    //前序遍历
    public void preOrder() {
        if (this.root != null) {
            this.root.preOrder();
        } else {
            System.out.println("二叉树为空，无法遍历！");
        }
    }

    //中序遍历
    public void infixOrder() {
        if (this.root != null) {
            this.root.infixOrder();
        } else {
            System.out.println("二叉树为空，无法遍历！");
        }
    }
    //后序遍历
    public void postOrder(){
        if (this.root != null) {
        this.root.postOrder();
        }else System.out.println("二叉树为空，");
        }
}
```

```java
public static void main(String[] args) {
    //先需要创建一颗二叉树
    BinaryTree binaryTree = new BinaryTree();
    //创建需要的结点
    HeroNode root = new HeroNode(1, "宋江");
    HeroNode node2 = new HeroNode(2, "吴用");
    HeroNode node3 = new HeroNode(3, "卢俊义");
    HeroNode node4 = new HeroNode(4, "林冲");
    HeroNode node5 = new HeroNode(5, "关胜");

    //手动创建二叉树
    root.setLeft(node2);
    root.setRight(node3);
    node3.setRight(node4);
    node3.setLeft(node5);
    binaryTree.setRoot(root);

    //测试前序遍历
    System.out.println("前序遍历");
    binaryTree.preOrder();  //1-2-3-5-4
    //测试中序遍历
    System.out.println("中序遍历");
    binaryTree.infixOrder();//2-1-5-3-4
    //测试中序遍历
    System.out.println("后序遍历");
    binaryTree.postOrder();//2-5-4-3-1


}
```



**二叉树-查找指定结点**

要求：

1. 请编写前序查找，中序查找和后序查找的方法
2. 并分别使用三种查找方式，查找heroNo = 5的结点
3. 并分析各种查找方式，分别比较了多少次

**思路分析**

前序查找思路：

1. 先判断当前结点no是否等于要查找结点
2. 如果相等，则返回当前结点
3. 如果不等，则判断当前结点的左子结点是否为空，如果不为空，则递归前序查找。
4. 如果左递归前序查找，找到结点则返回，否则继续判断当前结点的右子结点是否为空，如果不为空，则继续向右递归前序查找。

中序查找思路：

1. 判断当前结点的左子结点no是否为空，如果不为空，则递归中序查找
2. 如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点，否则继续向右递归中序查找。
3. 如果右递归中序查找找到就返回，如果没有找到就返回null

后序查找思路：

1. 先判断当前结点的左子结点是否等于要查找的结点，如果不是，则递归后序查找。
2. 如果找到了，就返回，如果没有找到，就和当前结点的右子结点比较是否一样，如果没有找到，就继续向右递归后序查找。
3. 如果找到了就返回，如果没有找到。就和当前结点进行比较，如果等于要找的结点就返回，如果没有就返回null

**代码实现**

```java
//前序遍历查找的方法
public HeroNode preOrderSearch(int no) {
    System.out.println("进入前序遍历！");
    //先判断当前结点的no是否等于要查找的no
    if (this.no == no) {
        return this;
    }
    //定义一个接收结点
    HeroNode resNode = null;
    //如果当前结点不是，那就想左子结点找
    if (this.left != null) {
        resNode = this.left.preOrderSearch(no);
    }
    if (resNode != null) {//左子结点递归查找完了，如果找到，就返回结果
        return resNode;
    }
    //如果左子结点递归查找完了，没有找到，就右递归找
    if (this.right != null) {
        resNode = this.right.preOrderSearch(no);
    }
    return resNode;//不管找没找到，都返回（没找到返回null）
}

//中序遍历查找
public HeroNode infixOrderSearch(int no) {
    HeroNode resNode = null;
    if (this.left != null) {
        resNode = this.left.infixOrderSearch(no);
    }
    if (resNode != null) {
        return resNode;
    }
    System.out.println("进入中序遍历！");
    if (this.no == no) {
        return this;
    }
    if (this.right != null) {
        resNode = this.right.infixOrderSearch(no);
    }
    return resNode;
}

//后序遍历查找
public HeroNode postOrderSearch(int no) {
    HeroNode resNode = null;
    if (this.left != null) {
        resNode = this.left.postOrderSearch(no);
    }
    if (resNode != null) {
        return resNode;
    }
    if (this.right != null) {
        resNode = this.right.postOrderSearch(no);
    }
    if (resNode != null) {
        return resNode;
    }
    System.out.println("进入后序遍历！");
    if (this.no == no) {
        return this;
    }
    return resNode;
}
```



**二叉树删除结点**

要求：（规定）

1. 如果删除的结点是叶子结点（没有子结点的结点），则删除该结点
2. 如果删除的结点是非叶子结点，则删除该子树
3. 测试，删除掉5号字而已结点和3号子树

**删除结点的思路**

1. 还需要考虑，如果根结点本身就是空的情况下，是没有办法删除的，则等价于将二叉树置空。
2. 因为我们的二叉树是单向的，所以我么是判断当前结点的子结点是否需要删除，而不能判断当前结点是不是需要删除的结点。
3. 如果当前结点的左子结点不为空并且左子结点就是要删除的结点，就像this.left = null，并且就结束递归，结束删除任务。
4. 如果当前当前结点的右子结点不为空，并且右子结点就是要删除的结点，就将this.right = null.并且就结束递归，结束删除任务。
5. 如果第2和第3步没有删除结点，那么我们就向左子树进行递归删除。
6. 如果向左子树没有删除成功，我们就需要向右子树继续递归删除。

**代码实现**

```java
//递归删除结点
//1、如果要删除的结点是子叶结点，就删除该结点
//2、如果删除的结点不是叶子结点，就删除该结点的子树
public void delNode(int no) {

    //判断当前结点的左子结点是不是要删除的结点
    if (this.left != null && this.left.no == no) {
        this.left = null;
        return;
    }
    //判断当前结点的左子结点是不是要删除的结点
    if (this.right != null && this.right.no == no) {
        this.right = null;
        return;
    }
    //如果当前结点的左右子结点都不是要删除的结点
    //继续向左子树递归
    if (this.left != null) {
        this.left.delNode(no);
    }
    //左边递归完了，没有找到就向右边递归
    if (this.right != null) {
        this.right.delNode(no);
    }
}
```



二叉树里的方法

```java
//删除结点
public void delNode(int no) {
    if (root != null) {//先判断一下根结点是不是空的
        if (root.getNo() == no){
            root = null;
        }else {
            root.delNode(no);
        }
    } else {//如果跟结点是空的
        System.out.println("根结点为空！");
    }
}
```



**顺序存储二叉树**

基本说明：从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组，看下面的示意图：

![image-20210609095816505](/Users/mac/Library/Application Support/typora-user-images/image-20210609095816505.png)



要求：

1. 上图的二叉树的结点，要求以数组的方式来存放
2. 遍历的时候仍然以树的方式遍历（前序遍历、中序遍历、后序遍历）

**顺序存储二叉树的特点**

1. 顺序二叉树通常只考虑完全二叉树
2. 第n个元素的左子结点为2*n+1
3. 第n个元素的右子结点为2*n+2
4. 第n个元素的父结点为(n-1)/2
5. n表示二叉树中的第几个元素（按0开始编号 ）



**代码实现**

```java
class ArrBinaryTree {
    private int[] arr;

    public ArrBinaryTree(int[] arr) {
        this.arr = arr;
    }
    //重载
    public void preOrder() {
        this.preOrder(0);
    }

    public void infixOrder() {
        this.infixOrder(0);
    }

    public void postOrder(){
        this.postOrder(0);
    }

    //编写一个方法完成顺序存储二叉树
    public void preOrder(int index) {
        if (arr == null || arr.length == 0) {
            System.out.println("数组为空，不能遍历");
        }
        //输出当前这个元素
        System.out.println(arr[index]);
        //向左递归遍历
        if (index * 2 + 1 < arr.length) {
            preOrder(index * 2 + 1);
        }
        //向右递归遍历
        if (index * 2 + 2 < arr.length) {
            preOrder(index * 2 + 2);
        }
    }

    //中序存储二叉树
    public void infixOrder(int index) {
        if (arr == null && arr.length == 0) {
            System.out.println("数组为空，不能遍历");
        }
        //向左递归遍历
        if (index * 2 + 1 < arr.length) {
            infixOrder(index * 2 + 1);
        }
        //输出当前结点
        System.out.println(arr[index]);
        //向右递归遍历
        if (index * 2 + 2 < arr.length) {
            infixOrder(index * 2 + 2);
        }
    }

    //后序存储二叉树
    public void postOrder(int index) {
        if (arr == null || arr.length == 0) {
            System.out.println("链表为空，无法存储");
        }
        //向左递归遍历
        if (index * 2 + 1 < arr.length) {
            postOrder(index * 2 + 1);
        }
        //向右递归
        if (index * 2 + 2 < arr.length) {
            postOrder(index * 2 + 2);
        }
        //输出当前的结点
        System.out.println(arr[index]);
    }
}
```



**线索化二叉树**

先看一个问题：将数列{1,3,6,8,10,14}构建成一颗二叉树

![image-20210609110307267](/Users/mac/Library/Application Support/typora-user-images/image-20210609110307267.png)



问题分析：

1. 当我们对上面的二叉树进行中序遍历时，数列为{8,3,10,1,14,6}
2. 但是6,8,10,14这几个结点的左右指针，并没有完全的利用上
3. 如果我们希望充分的利用各个结点的左右指针，让各个结点可以指向自己的前后结点，该怎么办？
4. 解决方案：线索二叉树

**线索二叉树基本介绍**

1. n个结点的二叉链表中含有n+1个空指针域，利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为“线索”）
2. 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树（Threaded BinaryTree）。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树
3. 一个结点的前一个结点，称为**前驱**结点
4. 一个结点的后一个结点，称为**后继**结点

![image-20210609141936228](/Users/mac/Library/Application Support/typora-user-images/image-20210609141936228.png)

说明：当线索化二叉树后，Node结点属性left和right，有如下情况：

1. left指向的是左子树，也可能指向的前驱结点。比如：1结点left指向的左子树，而10结点的left指向的是前驱结点

2. right指向的是右子树，也可能是指向后继结点。比如：1结点right指向的是右子树，而10结点right指向的是后继结点。

3. ```java
   //说明：
   //如果leftType == 0 表示指向的是左子树，如果==1表示指向前驱结点
   //如果rightType == 0 表示指向的是右子树，如果==1表示指向后继结点
   ```

**代码实现**

```java
//编写对二叉树进行中序线索化的方法
public void threadedNodes(HeroNode node) {
    //如果node==null，不能线索化
    if (node == null) {
        return;
    }
    //一、先线索化左子树
    threadedNodes(node.getLeft());
    //二、再处理当前结点的前驱结点
    if (node.getLeft() == null) {
        node.setLeft(pre);
        node.setLeftType(1);//指向的是前驱结点
    }

    //处理当前结点的后继结点（这一步是在进行下一个结点操作的时候才做的）
    if (pre != null && pre.getRight() == null) {
        //让前驱结点的右指针指向当前结点
        pre.setRight(node);
        //修改当前结点的右指针类型
        pre.setRightTyp(1);
    }
    //最关键的一步：每处理一个结点后，让当前结点是下一个结点的前驱结点
    pre = node;
    //三、线索化右子结点
    threadedNodes(node.getRight());
}
```



**遍历线索二叉树**

说明：对前面的中序线索化的二叉树，进行遍历

分析：因为线索化后，各个结点指向有变化，因此原来的遍历方式哦不能使用，这时需要使用新的方式遍历线索二叉树，各个结点可以通过线性方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。遍历的次序应当和中序遍历保持一致。

**代码实现**

```java
//遍历线索化二叉树的方法
public void threadedList() {
    //定义一个变量存储当前遍历的结点
    HeroNode node = root;

    while (node != null) {
        //循环判断找到leftType == 1的结点，第一个就是8
        //后面随着遍历而变化，因为leftType == 1时，说明该结点是按照锡奥所花
        //处理之后的结点
        while (node.getLeftType() == 0) {//这里就在一直找
            node = node.getLeft();
        }
        //找到过后输出
        System.out.println(node);
        //如果当前结点的右指针是后继结点，就一直输出
        while (node.getRightTyp() == 1){
            node = node.getRight();
            System.out.println(node);
        }
        //替换这个遍历的结点
        node = node.getRight();
    }

```



## 算法部分

### 递归

递归的概念：递归就是方法自己调用自己，每次调用时传入不同的变量。递归有助于编程者解决复杂的问题，同时可以让代码变得简洁。



**两个小案例**

1. 打印问题
2. 阶乘问题

递归调用规则：

1. 当程序执行到一个方法时，就会开辟一个独立的空间（栈）

![image-20210521100500202](/Users/mac/Library/Application Support/typora-user-images/image-20210521100500202.png)

**递归能解决什么样的问题？**

1. 各种数学问题如：8皇后问题，汉诺塔问题，阶乘问题，迷宫问题，球和篮子的问题
2. 各种算法中也会使用到递归，比如：快排，归并查找，二分查找，分支算法等、
3. 将用栈解决的问题---->递归，代码比较简洁

**递归需要遵循的重要规则**

1. 执行一个方法的时候，就创建一个新的受保护的独立空间（栈空间）
2. 方法的局部变量是独立的，不会互相影响，比如n遍历
3. 如果方法中使用的是引用类型的变量，就会共享该引用类型的数据
4. 递归必须向退出递归的条件逼近，否则就无限递归了
5. 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。



**递归-迷宫回溯问题**



```java
public static void main(String[] args) {
    //先创建一个地图
    //8行7列，1表示墙
    int[][] map = new int[8][7];
    //设置墙
    for (int i = 0; i < 7; i++) {
        map[0][i] = 1;
        map[7][i] = 1;
    }
    for (int j = 0; j < 8; j++) {
        map[j][0] = 1;
        map[j][6] = 1;
    }
    //设置挡板
    map[3][1] = 1;
    map[3][2] = 1;

    System.out.println("---------------------------迷宫地图-------------------");
    //打印墙（遍历）
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 7; j++) {
            System.out.print(map[i][j] + " ");
        }
        System.out.println();
    }
    setWay2(map,1,1);
    System.out.println("---------------------------小球找过路后的地图-------");

    //打印墙（遍历）
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 7; j++) {
            System.out.print(map[i][j] + " ");
        }
        System.out.println();
    }


}
```

```java
//使用递归回溯来给小球找路
//说明:
//1.map表示地图
//2.i,j表示从地图的那个位置开始出发（i，j）
//3.如果小球能到map[6][5]位置，则说明通路找到了
//4、约定：当map[i][j]为0时，表示该点没有走过，当为1时表示墙，当为2时表示通路可以走，如果为3表示该位置已经走过，但是走不通
//5.在走迷宫时，需要确定一个策略（方法） 下->右->上->左  如果走不通，再回溯。

/**
 *
 * @param map 表示地图
 * @param i 从哪个位置开始找
 * @param j
 * @return 如果找到通路，就犯规true ，否则返回false
 */
public static boolean setWay(int[][] map,int i,int j) {
    if (map[6][5] == 2) {//表示通路已经找到
        return true;
    } else {//通路没有找到，开始寻找
        if (map[i][j] == 0) {//如果当前的点还没有走过
            map[i][j] = 2; //先假定这个点可以走通
            if (setWay(map, i - 1, j)) {//向下走
                return true;//如果能走通
            } else if (setWay(map, i, j + 1)) {//向右走
                return true;
            } else if (setWay(map, i + 1, j)) {//向下走
                return true;
            } else if (setWay(map, i, j - 1)) {//向左走
                return true;
            }else {//说明该点是死路
                map[i][j] = 3;
                return false;
            }
        } else {
            return false;
        }
    }
}
```



### 八皇后问题

八皇后问题：是回溯算法的典型案例。该问题是在8x81格的国籍象棋上摆放八个皇后，使其不能相互攻击，即：**任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法**

使用回溯算法

八皇后算法的思路分析：

1. 第一个皇后先放第一行第一列
2. 第二个皇后放在第二行第一列、然后判断是否OK，如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适的
3. 继续第三个皇后，还是第一列、第二列.....。直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解。
4. 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到。
5. 然后回头继续第一个皇后放第二列，后面继续循环执行1、2、3的步骤。



说明：理论上应创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一位数组即可解决问题。

arr[8] = {0,4,7,5,2,6,1,3}//对应arr下标表示第几行，即第几个皇后。arr[i]  = val,val表示第i+1个皇后，放在第i+1行的第val+1列



## 排序算法



排序算法也称排序，是将一组数据，依指定的顺序进行排列的过程。

排序的分类：

1. 内部排序：指将需要处理的所有数据都加载到内部存储器中进行排序
2. 外部排序法：数据量过大，无法全部加载到内存中，需要借助外部存进行排序
3. 常见的排序算法分类如下：

![image-20210528085237732](/Users/mac/Library/Application Support/typora-user-images/image-20210528085237732.png)

#### 算法的时间复杂度

度量一个程序（算法）执行时间的两种方法

1. 事后统计法（不准确）
2. 事前估算法

#### 时间频度

一个算法花费的时间与算法中语句执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)

![image-20210528090202027](/Users/mac/Library/Application Support/typora-user-images/image-20210528090202027.png)

![image-20210528090405662](/Users/mac/Library/Application Support/typora-user-images/image-20210528090405662.png)

![image-20210528090612794](/Users/mac/Library/Application Support/typora-user-images/image-20210528090612794.png)

![image-20210528090705804](/Users/mac/Library/Application Support/typora-user-images/image-20210528090705804.png)

#### 时间复杂度

1. 一般情况下：算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示。若某个辅助函数f(n)，🙆当n趋近于无穷大时，T(n)/f(n)的极限值为不等于0的常数，则称f(n)是T(n)的同数量级函数。记作T(n) = O(f(n))，称O(f(n))为算法的渐进时间复杂度，简称时间复杂度。

2. T(n)不同，但时间复杂度可能相同。![image-20210528091348155](/Users/mac/Library/Application Support/typora-user-images/image-20210528091348155.png)

   他们的T(n)不同，但时间复杂度相同，都是O(n²)

3. 计算时间复杂度的方法:

   1. 用常数1来代替运行时间中的所有加法常数
   2. 修改后的运行次数函数中，只保留常数项
   3. 去除最高阶项的次数



常见的时间复杂度（8个）

![image-20210528092016579](/Users/mac/Library/Application Support/typora-user-images/image-20210528092016579.png)



#### 平均时间复杂度和最坏时间复杂度

1. 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间
2. 最坏情况下的时间复杂度称为最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行的界限，这就保证了算法的运行时间不会比最坏情况更长。
3. 平均时间复杂度和最坏时间复杂度是否一致，和算法有关。
4. ![image-20210528093923099](/Users/mac/Library/Application Support/typora-user-images/image-20210528093923099.png)



#### 算法的空间复杂度

基本介绍：

1. 类似于时间复杂度的讨论：一个算法的空间复杂度（Space Complexity）定义为该算法所耗费的存储空间，它也是问题规模n的函数。
2. 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的度量。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况。
3. 在做算法分析的时候，主要讨论的是时间复杂度。从用户使用体验上看，更看重的是程序的执行速度。一些缓存产品（redis，memcache）和算法（基本排序）**本质就是用空间换时间**。



### 冒泡排序（Bubble Sorting）

冒泡排序的基本思路是：通过对待排序序列从前向后（从下标较小的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素从前向后移动，就像水底下的气泡一样逐渐上冒。

因为排序排序过程中各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设立一个flag标志判断元素是否进行过交换。从而减少不必要的比较。（优化）



![image-20210528100454121](/Users/mac/Library/Application Support/typora-user-images/image-20210528100454121.png)

小结冒泡排序规则：

1. 一共进行数组的大小-1次大的循环
2. 每一趟排序的次数在逐渐地减少
3. 如果我们发现在某趟排序中，没有发生一次交换，可以提交结束排序

**代码实现**

最基本的实现

```java
public static void main(String[] args) {
    int[] arr = {3, 9, -1, 10, -2};
    int temp = 0;
  //时间复杂度是O(n²)
    for (int i = 0; i < arr.length - 1; i++) {
        for (int j = 0; j < arr.length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
        System.out.println("第" + (i + 1) + "趟排序后的数组");
        System.out.println(Arrays.toString(arr));
    }
}
```

优化：在某趟没有发生交换的时候，说明已经排序好了，停止冒泡

```java
public static void main(String[] args) {
    int[] arr = {3, 9, -1, 10, 20};
    int temp = 0;
    boolean flag = false;//标识变量，表示是否进行过交换
    for (int i = 0; i < arr.length - 1; i++) {
        for (int j = 0; j < arr.length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                //进行交换了，把表示设为true
                flag = true;
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
        System.out.println("第" + (i + 1) + "趟排序后的数组");
        System.out.println(Arrays.toString(arr));

        if (!flag){//如果里面的循环走完了，都没有进行交换，说明里面已经拍好顺序了，直接退出
            break;
        }else {//如果循环走完一趟，发现有交换，再把flag重置，继续执行
            flag = false;
        }
    }
}
```



### 选择排序

选择排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。

**排序思想**

第一次从arr[0] -arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]-arr[n-1]中选取最小值，与arr[1]交换，以此类推，总共进行n-1次，得到一个从小到大排列的有序序列。

说明：

1. 选择排序一共有数组大小-1轮排序
2. 每1轮排序，又是一个循环
   1. 先假定当前的数是最小数
   2. 然后和后面的每一个数进行比较，如果发现有比当前数更小的数，就重新确定最小数，并得到下标
   3. 每遍历到数组的最后时，就得到本轮最小数和下标
   4. 交换



例子：有一群牛，颜值分别是101，34，119，1请使用选择排序从低到高进行排序

```java
public static void selectSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {//一共进行了arr.length -1 轮
        int minIndex = i;
        int min = arr[i];
        for (int j = i + 1; j < arr.length; j++) {//每一轮又是一个循环
            if (min > arr[j]) {//如果最小的这个数大于后面的数，重置最小值
                min = arr[j];
                minIndex = j;
            }
        }
        if (minIndex != i) {//其实min就相当于一个临时变量
            arr[minIndex] = arr[i];
            arr[i] = min;
        }
        //将最小值和当前比对的值进行交换

        System.out.println("第" + (i + 1) + "轮后");
        System.out.println(Arrays.toString(arr));
    }
}
```



经过试验，选择排序比冒泡排序块，80000个数据只需要2s



### 插入排序

插入排序属于内部排序法，是对欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。

**基本思想**

把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中又有一个元素，无序表中包含有n-1个元素，排序的过程中每次从无序表中取出第一个元素，把它的排序码依次与有序元素的排序码进行比较，将他插入到有序表中的适当位置，使之成为新的有序表。



例子：有一群牛，颜值分别是101，34，119，1请使用选择排序从低到高进行排序

```java
for (int i = 1; i < arr.length; i++) {
    int insertValue = arr[i];//要插入的值
    int insertIndex = i - 1;//插入的前一个值的索引
    while (insertIndex >= 0 && insertValue < arr[insertIndex]) {
        //把前一个后移
        arr[insertIndex + 1] = arr[insertIndex];
        insertIndex--;
    }
    arr[insertIndex + 1] = insertValue;
    System.out.println("第"+i+"轮排序后的结果为：");
    System.out.println(Arrays.toString(arr));
}
 /**

         //第一轮
         int insertValue = arr[1];//要插入的值
         int insertIndex = 1 -1;//插入的前一个值的索引

         //当要插入的前一个值的索引大于等于0，并且前面的值大于要插入的值的时候，开始交换
         //因为前面的都是有序的
         while (insertIndex >= 0 && insertValue < arr[insertIndex]){
         //把前一个后移
         arr[insertIndex + 1] = arr[insertIndex];
         insertIndex--;
         }
         arr[insertIndex + 1] = insertValue;
         System.out.println("第一轮排序后的结果为：");
         System.out.println(Arrays.toString(arr));

         insertValue = arr[2];
         insertIndex = 2 -1;

         while (insertIndex >= 0 && insertValue < arr[insertIndex]){
         //把前一个后移
         arr[insertIndex + 1] = arr[insertIndex];
         insertIndex--;
         }
         arr[insertIndex + 1] = insertValue;
         System.out.println("第2轮排序后的结果为：");
         System.out.println(Arrays.toString(arr));



         insertValue = arr[3];
         insertIndex = 3 -1;

         while (insertIndex >= 0 && insertValue < arr[insertIndex]){
         //把前一个后移
         arr[insertIndex + 1] = arr[insertIndex];
         insertIndex--;
         }
         arr[insertIndex + 1] = insertValue;
         System.out.println("第3轮排序后的结果为：");
         System.out.println(Arrays.toString(arr));
         */
```

![image-20210530203246008](/Users/mac/Library/Application Support/typora-user-images/image-20210530203246008.png)



### 希尔排序

希尔排序是希尔提出的，也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。

**基本思想**

希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分为一组，算法便终止。

![image-20210530204908917](/Users/mac/Library/Application Support/typora-user-images/image-20210530204908917.png)



例子：有一群小牛，考试成绩分别是{8,9,1,7,2,3,5,4,6,0}请从小到大排序，请分别使用

1. 希尔排序时，对有序序列在插入时采用交换法，并测试排序速度。
2. 希尔排序时，对有序序列在插入时采用移动法，并测试排序速度。





**代码实现**

(交换法)

```java
 //第一轮排序
    int temp = 0;
    for (int i = 5; i < arr.length; i++) {//分为5组
        for (int j = i - 5; j >= 0; j -= 5){//遍历每一组的数据
            if (arr[j] > arr[j+5]){
                temp = arr[j];
                arr[j] = arr[j+5];
                arr[j+5] = temp;
            }
        }
    }
    System.out.println("第1轮交换晚后的数据是");
    System.out.println(Arrays.toString(arr));

    //第二轮排序，分为两组
    temp = 0;
    for (int i = 2; i < arr.length; i++) {//分为5组
        for (int j = i - 2; j >= 0; j -= 2){//遍历每一组的数据
            if (arr[j] > arr[j+2]){
                temp = arr[j];
                arr[j] = arr[j+2];
                arr[j+2] = temp;
            }
        }
    }
    System.out.println("第2轮交换晚后的数据是");
    System.out.println(Arrays.toString(arr));
}
```



代码整合后（交换法）

```java
public static void shellSort(int[] arr) {
    int temp = 0;
    int count = 0;
    for (int gap = arr.length / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < arr.length; i++) {//分为5组
            for (int j = i - gap; j >= 0; j -= gap) {//遍历每一组的数据
                if (arr[j] > arr[j + gap]) {
                    temp = arr[j];
                    arr[j] = arr[j + gap];
                    arr[j + gap] = temp;
                }
            }
        }
        System.out.println("第" + (++count) + "轮交换晚后的数据是");
        System.out.println(Arrays.toString(arr));
    }
}
```



**算法改进（移位法）**

```java
public static void shellSort2(int[] arr) {
    for (int gap = arr.length / 2; gap > 0; gap /= 2) {
        //从第gap个元素开始，逐个对其所在的组进行直接插入排序
        for (int i = gap; i < arr.length; i++) {
            int j = i;
            int temp = arr[j];
            if (arr[j]<arr[j-gap]) {//直接插入排序
                while (j - gap >= 0 && temp < arr[j - gap]){
                  arr[j] = arr[j-gap];
                  j-=gap;
                }
                //当退出循环的时候，就给temp找到了放置的位置
                arr[j] = temp;
            }
        }
    }
}
```



### 快速排序

是对冒泡排序的一种改进。基本思想是：

通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

**代码实现**

```java
public static void quickSort(int[] arr, int left, int right) {
    int l = left;//左下标
    int r = right;//由下标

    //pivot 中轴值
    int pivot = arr[(left + right) / 2];
    int temp = 0;//交换时使用
    //while循环的目的是让比pivot值小的放到左边，
    //比pivot值大的放到右边
    while (l < r) {

        while (arr[l] < pivot) {
            //在pivot左边一直找，直到找到一个大于等于pivot的值
            l += 1;
        }
        while (arr[r] > pivot) {
            //在pivot右边一直找，直到找到一个小于等于pivot的值
            r -= 1;
        }
        //找到以后要干什么呢？交换
        if (l >= r) {//说明左右两边的值，已经按照左边小于等于pivot,右边全部是大于等于pivot的值
            break;
        }
        //交换
        temp = arr[l];
        arr[l] = arr[r];
        arr[r] = temp;

        //如果交换完了发现arr[l] == pivot值相等 ，那么就--，前移
        if (arr[l] == pivot) {
            r -= 1;
        }
        //如果交换完了发现arr[r] == pivot值相等 ，那么就--，前移
        if (arr[r] == pivot) {
            l += 1;
        }
    }
    if (l == r) {
        l += 1;
        r -= 1;
    }
    //向左递归
    if (left < r){
        quickSort(arr,left,r);
    }
    //向右递归
    if (l < right){
        quickSort(arr,l,right);
    }
}
```



### 归并排序

归并排序（MERGE-SORT‘）是利用归并的思想实现的排序方法，该算法采用经典的分治策略（分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案“修补”在一起，即分而治之）

![image-20210604101350062](/Users/mac/Library/Application Support/typora-user-images/image-20210604101350062.png)

![image-20210604101222361](/Users/mac/Library/Application Support/typora-user-images/image-20210604101222361.png)



### 基数排序

1. 基数排序属于”分配式排序“，又称”桶子发“或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些”桶“中，达到排序的作用
2. 基数排序法是属于稳定性的排序，基数排序法是效率高的稳定性排序法
3. 基数排序是桶排序的扩展
4. 基数排序是1887年赫尔曼·何乐发明的，它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较



**基数排序的基本思想**

1. 将所有待比较数值统一为同样的位数长度，数位较短的数前面补零。然后，从最低位开始，依次进行依次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成了一个有序数列
2. 图文解释a

![image-20210605170549066](/Users/mac/Library/Application Support/typora-user-images/image-20210605170549066.png)

![image-20210605170754707](/Users/mac/Library/Application Support/typora-user-images/image-20210605170754707.png)

![image-20210605170939895](/Users/mac/Library/Application Support/typora-user-images/image-20210605170939895.png)

![image-20210605171005284](/Users/mac/Library/Application Support/typora-user-images/image-20210605171005284.png)



**代码实现**

```java
public static void radixSort(int[] arr) {

    //先得到数组中最大的数的位数
    int max = arr[0];
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    //得到最大数的位是几位数
    int maxLength = (max + "").length();
    //定义一个二维数组，表示十个桶
    //说明：
    //1、二维数组包含10个一位数组
    //2、为了防止在放入数的时候，数据溢出，则每一个数组（桶）,大小为arr.length
    //3、明确：基数排序是适用空间换时间的经典排序
    int[][] bucket = new int[10][arr.length];

    //为了记录每个桶中，实际放了多少个数据，我们定义一个一位数组来记录各个桶每次放入的数据的个数
    //比如：bucketElementCounts[0],记录的就是bucket[0]桶的放入数据的个数
    int[] bucketElementCounts = new int[10];


    //开始循环
    for (int k = 0, n = 1; k < maxLength; k++, n *= 10) {//对大有几位就循环几次
        //第k轮，对个对应的数进行排序
        for (int j = 0; j < arr.length; j++) {
            int digitOfElement = arr[j] / n % 10;//   digitOfElement 每个元素的对应位数
            //第digitOfElement桶的第bucketElementCounts[digitOfElement]元素是arr[j]
            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
            //++的原因：如果下一次算出来的个位数还是digitOfElement，就让它放到下一个位置去
            bucketElementCounts[digitOfElement]++;//放进去以后放让存放
        }

        int index = 0;
        //依次把10个桶里面的数据放回到arr数组中
        for (int i = 0; i < bucketElementCounts.length; i++) {//遍历每一个桶
            if (bucketElementCounts[i] != 0) {
                //从第一个桶开始
                for (int j = 0; j < bucketElementCounts[i]; j++) {
                    arr[index++] = bucket[i][j];
                }
            }
            //第一轮处理后，需要将bucketElementCounts[i] = 0 !!!!!
            bucketElementCounts[i] = 0;
        }
        System.out.println("遍历完"+(k+1)+"位数后的结果=" + Arrays.toString(arr));
    }
}
```



注意事项：如果数据量比较大，可能会造成内存溢出！

### 常用排序算法的总结和对比

常用术语：

1. 稳定：如果原本a在前面，而a=b，排序之后a仍然在b的前面
2. 不稳定：与稳定相反
3. 内排序：所有排序操作都是在内存中完成的
4. 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行
5. 时间复杂度：一个算法执行所消耗的时间
6. 空间复杂度：运行完一个程序所需要的内存的大小
7. n:数据的规模
8. k:”桶的个数“
9. In-place:不占用额外内存
10. Out-place:占用额外内存

![image-20210605182108683](/Users/mac/Library/Application Support/typora-user-images/image-20210605182108683.png)



## 查找算法

在Java中，我们常用的查找有四种：

1. 顺序（线性）查找
2. 二分查找/折半查找
3. 插值查找
4. 斐波那契查找



### 线性查找

有一个数列{1,8,10,89,1111,1234},判断数列中是否包含此名称{顺序查找}，要求：如果找到了，就提示找到，并给出下标值。

思路：如果查找到全部符合条件的值

**代码实现**

线性查找就是遍历

```java
public static int seqSearch(int[] arr,int value){
    for (int i = 0;i < arr.length;i++){
        if (arr[i] == value){
            return i;
        }
    }
    return -1;
}
```



### 二分查找法

二分查找：请对一个有序数组进行二分查找{1,8,10,89,1000,1234},请输入一个数看看该数组是否存在次数，并且求出下标，如果没有就提示”没有这个数“。



思路分析：

1. 首先确定该数组在中间下标

   mid = (left + right) / 2

2. 然后让需要查找的数findVal和arr[mid]比较

   1 findVal > arr[mid]，说明你要查找的数在mid的右边，因此需要递归的向右查找

   2 findVal < arr[mid]，说明你要查找的数在mid的左边，因此需要递归的向左查找

   3 findVal = arr[mid]，说明找到，就返回

   

   什么时候需要退出递归

   1. 找到就结束递归
   2. 递归完整个数组，仍然没有找到findVal,也需要结束递归 当left > right 就需要退出

   

   **代码实现**

   ```java
   /**
    * @param arr     数组
    * @param left    左边的索引
    * @param right   右边的索引
    * @param findVal 要查找的数
    * @return 如果找到就返回索引，找不到就返回-1
    */
   public static int binarySearch(int[] arr, int left, int right, int findVal) {
       if (left > right) {
           return -1;
       }
       int mid = (left + right) / 2;
       int midValue =arr[mid];
   
       if (findVal > midValue) {//向右递归
           return  binarySearch(arr, mid + 1, right, findVal);
       } else if (findVal < midValue) {//向左递归
          return binarySearch(arr, left, mid - 1, findVal);
       } else {
           return mid;
       }
   }
   ```

   

**代码完善，有多个相同值的时候**

```java
public static ArrayList<Integer> binarySearch2(int[] arr, int left, int right, int findVal) {
    if (left > right) {
        return new ArrayList<Integer>();
    }
    int mid = (left + right) / 2;
    int midValue = arr[mid];

    if (findVal > midValue) {//向右递归
        return binarySearch2(arr, mid + 1, right, findVal);
    } else if (findVal < midValue) {//向左递归
        return binarySearch2(arr, left, mid - 1, findVal);
    } else {
        ArrayList<Integer> resIndexList = new ArrayList<Integer>();
        int temp = mid - 1;
        while (true) {
            if (temp < 0 || arr[temp] != findVal) {//退出
                break;
            }
            resIndexList.add(temp);
            temp -= 1;  //temp左移
        }
        resIndexList.add(mid);

        temp = mid + 1;
        while (true) {
            if (temp > arr.length - 1 || arr[temp] != findVal) {//退出
                break;
            }
            resIndexList.add(temp);
            temp += 1;
        }
        return resIndexList;
    }

}
```



### 插值查找算法

原理介绍：

1. 插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找

2. 将折半查找中的求mid索引的公式，low表示左边索引，hight表示右边索引。

   这里的key指的是我们要查找的值

   ![image-20210606160001074](/Users/mac/Library/Application Support/typora-user-images/image-20210606160001074.png)

   int midIndex = low + (higt -low) *(key -arr[low])/(arr[high] - arr[low])

   对应前面的代码公式：

   int mid = left + (right - lrft) * (findVal - arr[left]) / (arr[right] - arr[left])

   

   **代码实现**

   ```java
   /**
    * @param arr       传入的数组
    * @param left      左边的索引
    * @param right     右边的索引
    * @param findValue 查找值
    * @return 如果找到，就返回对应的下标，如果没有找到，就返回-1
    */
   public static int insertValueSearch(int[] arr, int left, int right, int findValue) {
       System.out.println("调用依一次");
   
       if (left > right) {
           return -1;
       }
       int mid = left + (right - left) * (findValue - left) / (arr[right] - arr[left]);
       int midValue = arr[mid];
   
       if (findValue > midValue) {//向右递归
           return insertValueSearch(arr, mid + 1, right, findValue);
       } else if (findValue < midValue) {
           return insertValueSearch(arr, left, mid - 1, findValue);
       }else {
           return mid;
   
       }
   }
   ```

3. 注意：

    对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找，速度较快。

   关键字分布不均匀的情况下，该方法不一样比折半查找好。



### 斐波那契（黄金分割）查找算法

**基本介绍**

1. 黄金分割点是指把一条线段分割成两个部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是0.618.由于按此比例设计的造型十分美丽，因此成为黄金分割，也称为中外比。这是一个神奇的数字，会带来意想不到的效果
2. 斐波那契数列{1,1,2,3,5,8,13,21,34,55}发现斐波那契数列的两个相邻数的比例，无限接近黄金分割值0.618。

**斐波那契（黄金分割法）原理**

1. 斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即 mid = low + F(k-1) -1

2. **对F(k-1) -1的理解**：由斐波那契数列F(k) = F(k-1) +  F(k-2) ,可以得到(F(k)-1) = (F(k-1)-1) + ( F(k-2)-1) +1。该式说明：只要顺序表的长度是F(k) -1，就可以将该表分成长度为                     F(k-1)-1和F(k-2)-1的两段，即如下所示。从而中间位置为mid = low + F(k-1) - 1。

   这里的mid就像是一份

例如：（F(6) -1） = （F(5)-1）+ 1 + （F(4)-1）==> 12 = 7 + 1(mid) + 4

![image-20210607104605055](/Users/mac/Library/Application Support/typora-user-images/image-20210607104605055.png)

类似的，每一子段也可以用相同的方式分割

但顺序表长度n不一定刚好等于F(k) -1，所以需要将原来的顺序表长度n增加至F(k)-1。这里的k值只要能使得F(k)-1恰好大于或等于n即可，由以下代码得到，顺序表长度增加后，新增的位置（从n+1到F(k)-1位置），都赋给n位置即可。



## 二叉树的应用



### 堆排序

1. 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn),它也是不稳定排序
2. 堆是具有以下性质的完全二叉树，每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆，注意：没有要求结点的左孩子的值和右孩子的值的大小关系。
3. 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。
4. 大顶堆举例说明：

![image-20210610094155456](file:///Users/mac/Library/Application%20Support/typora-user-images/image-20210610094155456.png?lastModify=1622730264)



小顶堆举例说明

![image-20210610094505196](file:///Users/mac/Library/Application%20Support/typora-user-images/image-20210610094505196.png?lastModify=1622730264)



**堆排序的基本思想**

1. 将待排序的序列构造成一个大顶堆。
2. 此时，整个序列的最大值就是堆顶的根结点。
3. 将其与末尾元素进行交换，此时末尾就为最大值
4. 然后将剩余n-1个元素重新构造成一个堆，这样就会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。



可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了。

原始的数组是【4，6，8，5，9】

![image-20210610103744576](file:///Users/mac/Library/Application%20Support/typora-user-images/image-20210610103744576.png?lastModify=1622730264)





![image-20210610103842374](file:///Users/mac/Library/Application%20Support/typora-user-images/image-20210610103842374.png?lastModify=1622730264)



![image-20210610103957703](file:///Users/mac/Library/Application%20Support/typora-user-images/image-20210610103957703.png?lastModify=1622730264)

![image-20210610104129396](file:///Users/mac/Library/Application%20Support/typora-user-images/image-20210610104129396.png?lastModify=1622730264)

此时，我们就将一个无序序列构造成了一个大顶堆。

**思路分析**

1. 将无序序列构成一个堆，根据升序降序需求选择大顶堆或者小顶堆；
2. 将堆顶元素与末尾元素交换，将最大元素”沉“到数组末端
3. 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序



**代码实现**

```
//将一个数组（二叉树），调整成一个大顶堆/
/**
 * 功能：完成以i对应的非叶子结点的树调整成大顶堆
 * 举例：int arr[] = {4,6,8,5,9}; => i = 1 =>adjustHeap =>得到{4,9,8,5,6}
 * 如果再次调用 adjustHeap 传入的是 i = 0 => 得到{4,9,8,5,6} => {9,6,8,5,4}
 *
 * @param arr    待调整的数组
 * @param i      表示非叶子结点在数组中的索引
 * @param length 表示对多少个元素继续调整，length是在逐渐的减少
 */
public static void adjustHeap(int arr[], int i, int length) {
    int temp = arr[i];//先把i这个结点的数存到临时变量中

    //从第i个元素的左子结点开始找起,找到子结点中最大的
    for (int k = 2 * i + 1; k < length; k = k * 2 + 1) {
        if (k + 1 < length && arr[k] < arr[k + 1]) {//说明左子结点的值小于右子结点
            k++;//k指向右子结点
        }
        if (arr[k] > temp) {//如果子结点的最大值大于父结点
            arr[i] = arr[k];//交换
            i = k;
        } else {
            break;
        }
    }
    //for循环后，我们已经将以i为父结点最大值，放在了最新（局部）
    arr[i] = temp;//将temp放到调整过后的位置
}
```



```
public static void main(String[] args) {
    int temp = 0;
    int[] arr = {4, 6, 8, 5, 9};
    int count = 1;
    for (int i = arr.length / 2 - 1; i >= 0; i--) {
        adjustHeap(arr, i, arr.length);
        System.out.println("第"+count+"次调整后的结果：" + Arrays.toString(arr));
        count++;
    }


    /**
     * 将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端
     * 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序
     */
    for (int j = arr.length - 1; j > 0; j--) {
        temp = arr[j];
        arr[j] = arr[0];
        arr[0] = temp;
        adjustHeap(arr,0,j);
    }
            System.out.println("数组等于：" + Arrays.toString(arr));
```



### 赫夫曼树

**基本介绍**：

1. 给定n个权值作为n个叶子结点，构造一颗二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)，还有的书翻译为赫夫曼树
2. 赫夫曼树是带权路径长度最短的树，权值较大的结点离根结点较近

**重要概念和距离说明**

1. 路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径，通路中分支的数目称为路径长度，若规定根结点的层数是1，则从根结点到第L层结点的路径长度是L-1。
2. **结点的权及带权路径长度**：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。
3. 树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为：WPL(weight path length),权值越大的结点离根结点越近的而二叉树才是最优二叉树
4. WPL最小的就是赫夫曼书

![image-20210611094756255](file:///Users/mac/Library/Application%20Support/typora-user-images/image-20210611094756255.png?lastModify=1622730264)



赫夫曼树创建思路：

给定一个数列：{13,7,8,3,29,6,1}要求转成一个赫夫曼树

1. 从小到大进行排序，将每一个数据，每个数据都是一个结点，每个结点可以看成是一颗最简单的二叉树
2. 取出根结点权值最小的两颗二叉树
3. 组成一颗新的二叉树，该新的二叉树的根结点的权值前面两颗二叉树根结点权值之和
4. 再将这颗新的二叉树，以根结点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树。

**代码实现**

```
 /**
     * @param arr 需要创建成赫夫曼树的数组
     * @return  创建好的赫夫曼树的root结点
     */
    //创建赫夫曼树的方法
    public static Node createHuffmanTree(int[] arr) {
        //第一步为了方便操作
        //1、遍历arr数组
        //2、将arr的每个元素构成一个Node
        //3、将Node放入到ArrayList当中
        ArrayList<Node> nodes = new ArrayList<>();
        for (int value : arr) {
            nodes.add(new Node(value));
        }
        while (nodes.size() > 1) {
            //从小到大排序
            Collections.sort(nodes);
//            System.out.println("nodes = " + nodes);
            //取出根节点最小的两颗二叉树
            //1、取出权值最小的节点（二叉树）
            Node leftNode = nodes.get(0);
            //2、取出权值第二小的节点（二叉树）
            Node rightNode = nodes.get(1);
            //3、构建一颗新的二叉树
            Node parent = new Node(leftNode.value + rightNode.value);
            parent.left = leftNode;
            parent.right = rightNode;
            //4、从ArrayList删除处理过的二叉树
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            //5、将新的二叉树的结点加入到链表
            nodes.add(parent);
        }
       return nodes.get(0);
    }
}
```



### 赫夫曼编码

**基本介绍**

1. 赫夫曼编码也翻译为 哈夫曼编码，又称霍夫曼编码，是一种编码方式，属于一种程序算法
2. 赫夫曼编码是赫夫曼树在电讯通信中的经典应用之一
3. 赫夫曼编码广泛的应用于数据文件压缩。其压缩率通常在20%-90%之间
4. 赫夫曼码是可变字长编码(VLC)的一种，Huffman与1952年提出的一种编码方式，称为最佳编码
5. ![image-20210611142014201](/Users/mac/Library/Application Support/typora-user-images/image-20210611142014201.png)



**编码过程介绍**

![image-20210611143605901](/Users/mac/Library/Application Support/typora-user-images/image-20210611143605901.png)

![image-20210611143648558](/Users/mac/Library/Application Support/typora-user-images/image-20210611143648558.png)

![image-20210611143711557](/Users/mac/Library/Application Support/typora-user-images/image-20210611143711557.png)

![image-20210611143729625](/Users/mac/Library/Application Support/typora-user-images/image-20210611143729625.png)

发送的时候还是以8bit一字节的形式发

赫夫曼压缩是无损压缩



**注意**：这个赫夫曼树根据排序方法的不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，**但是wpl是一样的**，都是最小的，比如：如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个。







功能：根据赫夫曼编码压缩数据的原理，需要创建”I like like like  java do you like java“对应的赫夫曼树

思路：

1. 构建一个新的结点 Node {data{存放数据};  weigh(权值)，left  right}
2. 得到 ”I like like like  java do you like java“对应的byte[]数组
3. 编写一个方法，将准备构建赫夫曼树的Node结点放到List,形式[Node{data=97,weight = 57},Node{data = 32,weight = 9},....]
4. 可以通过List创建对应的赫夫曼树



**代码实现**

```java
/**
 * 接收一个字节数组
 * @param bytes 接收字节数组
 * @return 返回的是一个List形式
 */
//获取节点
public static List<Node> getNodes(byte[] bytes) {
    //1、创建一个ArrayLists
    ArrayList<Node> nodes = new ArrayList<>();

    //2、遍历bytes数组,统计每一个人byte出现的次数
    HashMap<Byte, Integer> counts = new HashMap<>();
    for (byte b : bytes) {
        Integer count = counts.get(b);
        if (count == null) {//说明是第一次遍历
            //把这个数记作1
            counts.put(b, 1);
        } else {//这个数不是第一次出现
            counts.put(b, count + 1);//遇到一个byte就加一个
        }
    }
    //把每一个键值对转换成一个Node对象
    for (Map.Entry<Byte, Integer> entry : counts.entrySet()) {
        nodes.add(new Node(entry.getKey(), entry.getValue()));
    }

    return nodes;

}
```



```java
/**
 * 功能：将传入的Node结点的所有叶子结点的赫夫曼编码得到，并存放到huffmanCode集合中
 *
 * @param node          传入的结点
 * @param code          代表路径：左子节点是 0  右子节点是 1
 * @param stringBuilder 是用来拼接路径的
 */
private static void getCode(Node node, String code, StringBuilder stringBuilder) {
    StringBuilder stringBuilder2 = new StringBuilder(stringBuilder);
    stringBuilder2.append(code);
    if (node != null) {//如果node == null不处理
        //判断当前的结点是叶子结点还是非叶子结点
        if (node.data == null){//非叶子结点
            //递归处理
            //向左递归
            getCode(node.left,"0",stringBuilder2);
            //向右递归
            getCode(node.right,"1",stringBuilder2);
        }else {
            //说明是一个叶子结点
            //说明找到某个叶子结点的最后
            huffmanCodes.put(node.data,stringBuilder2.toString());
        }

    }
}
```



```java
/**
 * @param bytes        原始的字符串对应的byte数组
 * @param huffmanCodes 生成的赫夫曼编码
 * @return 返回赫夫曼编码处理后的一个byte数组
 * 举例：String content = "I like like like java do you like a java"; => byte[] contentBytes = content.getBytes();
 * 返回的字符串是"1010100010111111......."所对应的byte[] huffmanCodeByte,即8位对应一个byte
 * 放入到huffmanCodeByte[] 中
 * huffmanBodeBytes[0] = 10101000(补码) => byte [推导：10101000 => 10101000 - 1 => 10100111(反码)
 * => 11011000 -- >-88]
 */
private static byte[] zip(byte[] bytes, Map<Byte, String> huffmanCodes) {
    StringBuilder stringBuilder = new StringBuilder();
    //1、利用huffmanCode 将不有特殊 转成 赫夫曼编码对应的地字符串
    for (byte b : bytes) {
        String str = huffmanCodes.get(b);
        stringBuilder.append(str);
    }
    //System.out.println("赫夫曼编码压缩后的二进制字符串" + stringBuilder.toString());
    //确定编码后的长度
    int len;
    if (stringBuilder.length() % 8 == 0) {
        len = stringBuilder.length() / 8;
    } else {
        len = stringBuilder.length() / 8 + 1;
    }
    //创建数据压缩后的byte数组
    byte[] huffmanCodeBytes = new byte[len];
    int index = 0;//记录是第几个byte
    for (int i = 0; i < stringBuilder.length(); i += 8) {
        String strByte;
        if (i + 8 > stringBuilder.length()) {//不够8位
            strByte = stringBuilder.substring(i);
        } else {
            strByte = stringBuilder.substring(i, i + 8);
        }
        //将strByte转成一个byte放到huffmanCoeBytes里
        huffmanCodeBytes[index] = (byte) Integer.parseInt(strByte, 2);
        index++;
    }
    return huffmanCodeBytes;
}
```



```java
//编写一个方法对压缩数据的解码
/**
 * @param huffmanCodes 赫夫曼编码表
 * @param huffmanBytes 赫夫曼编码得到的字节数组
 * @return 返回的是
 */
private static byte[] deCode(Map<Byte, String> huffmanCodes, byte[] huffmanBytes) {
    //先得道HuffmanBytes 对应的二进制的字符串，形式：1010100010111
    StringBuilder stringBuilder = new StringBuilder();
    //将byte数组转成二进制的字符串
    for (int i = 0; i < huffmanBytes.length; i++) {
        byte b = huffmanBytes[i];
        //判断是不是最后一个字节。因为最后一个自己不需要补高位
        boolean flag = (i == huffmanBytes.length - 1);
        stringBuilder.append(byteToBitString(!flag, b));
    }
    System.out.println("赫夫曼编码字节数组对应的二进制字符串" + stringBuilder);

    //把字符串按照指定的赫夫曼编码进行解码
    //吧把赫夫曼编码表进行调换，因为反向查询 a->100  100->a
    HashMap<String, Byte> map = new HashMap<>();
    for (Map.Entry<Byte, String> entry : huffmanCodes.entrySet()) {
        map.put(entry.getValue(), entry.getKey());
    }
    //创建一个集合，存放byte
    ArrayList<Byte> list = new ArrayList<>();

    //I可以理解成是索引，扫描stringBuilder
    for (int i = 0; i < stringBuilder.length();) {
        int count = 1;//相当于是一个干活的，一直往后跑
        boolean flag = true;
        Byte b = null;
        while (flag) {
            //扫描stringBuilder
            String key = stringBuilder.substring(i, i + count);
            b = map.get(key);//看看扫描到的这个二进制在反编码表中有没有
            if (b == null) {//如果没有这个编码，让count继续往后扫描
                count++;
            } else {//如果找到一个直接退出
                flag = false;
            }
        }
        //while循环退出的时候，说明找到一个
        list.add(b);
        i += count;//subString不包含尾
    }
    //for循环结束以后，list就存放了所有的字符
    //把list中的数据放入到byte[]并返回
    byte b[] = new byte[list.size()];
    for (int i = 0; i < list.size(); i++) {
        b[i] = list.get(i);
    }
    return b;
}


//编写一个方法，将字符串对应的byte[]数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码 压缩后的byte[]

/**
 * 将一个byte转成二进制的字符串
 *
 * @param flag 标示是否需要补高位，如果是true，就标示要补高位，如果是false表示不补，如果是最后一个字节无需补高位
 * @param b    传入的byte
 * @return 是该b对应的二进制的字符串（按补码返回的）
 */
private static String byteToBitString(boolean flag, byte b) {
    //使用变量保存b
    int temp = b;//将b转成int
    //如果是正数还存在补高位
    if (flag) {
        temp |= 256;//按位与256    1 0000 0000 | 0000 0000 => 1 0000 0001
    }
    String str = Integer.toBinaryString(temp);//返回的是temp对应的二进制的补码
    if (flag) {
        return str.substring(str.length() - 8);
    } else {
        return str;
    }


}
```



### 赫夫曼编码的最佳实践 - 文件压缩

对文件的压缩和解压，具体要求：给定一个图片文件，要求对其进行无损压缩，看看压缩效果如何。

思路：读取文件->得到赫夫曼编码->完成压缩

```java
//编写一个方法：将一个文件压缩
public static void zipFile(String srcFile,String dstFile) {
    //创建输出流
    OutputStream os = null;
    ObjectOutputStream oos = null;
    //创建文件输入流
    FileInputStream is = null;
    try {
        //创建文件的输入流
        is = new FileInputStream(srcFile);
        //创建一个和源文件一样大小的数组
        byte[] b = new byte[is.available()];
        //读取文件
        is.read(b);
        //直接对源文件压缩
        byte[] huffmanBytes = huffmanZip(b);
        //创建文件的输出流，存放压缩文件
        os = new FileOutputStream(dstFile);
        //创建一个和文件输出流关联的ObjectOutputStream
        oos = new ObjectOutputStream(os);
        //把赫夫曼编码后的字节数组写入压缩文件
        oos.writeObject(huffmanBytes);
        //这里以对象流的方式写入赫夫曼编码，是为了以后恢复源数据
        //注意一定要把赫夫曼编码写入压缩文件
        oos.writeObject(huffmanCodes);
    }catch (Exception e){
        System.out.println(e.getMessage());
    }finally {
        try {
            is.close();
            os.close();
            oos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```



```java
//测试压缩文件的代码
String srcFile = "/Users/mac/Desktop/吉他谱/src.jpg";
String dstFile = "/Users/mac/Desktop/吉他谱/des.zip";
zipFile(srcFile,dstFile);
System.out.println("压缩文件成功");
```





### 赫夫曼编码最佳实践-文件压缩

具体要求：将前面的压缩文件，重新恢复成原来的文件

思路：读取压缩文件（数据和赫夫曼编码表）->完成解压

```java
//完成解压文件的方法

/**
 * @param zipFile 需要解压的文件
 * @param dstFile 解压到的路径
 */
public static void unZip(String zipFile,String dstFile){
    //定义文件的输入流
    InputStream is = null;
    //定义一个对象输入流
    ObjectInputStream ois = null;
    //定义文件的输出流
    OutputStream os = null;
    try{
        //创建文件输入流
       is =  new FileInputStream(zipFile);
       //创建一个和 is相关联的对象输入流
        ois = new ObjectInputStream(is);
        //读取byte[]数组和huffmanBytes
        byte[] huffmanBytes = (byte[])ois.readObject();
        //读取赫夫曼编码表
        Map<Byte,String> huffmanCodes = (Map<Byte,String>)ois.readObject();

        //解码
        byte[] bytes = deCode(huffmanCodes, huffmanBytes);
        //将bytes写入到目标文件
        os = new FileOutputStream(dstFile);
        //写数据到file文件
        os.write(bytes);

    }catch (Exception e){
        System.out.println(e.getMessage());
    }finally {
        try {
            ois.close();
            os.close();
            is.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
```



```java
//测试解压文件
String zipFile = "/Users/mac/Desktop/吉他谱/des.zip";
String dstFile = "/Users/mac/Desktop/吉他谱/src2.jpg";
unZip(zipFile,dstFile);
System.out.println("解压成功！");
```



### 赫夫曼编码压缩文件注意事项

1. 如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化。
2. 赫夫曼编码是按字节来处理的，因此可以处理所有的文件
3. 如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显。