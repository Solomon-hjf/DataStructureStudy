

# 数据结构和算法

## 数据结构

程序 = 数据结构 + 算法



### 线性结构和非线性结构

数据结构包括：线性结构和非线性结构

**线性结构**

1. 线性结构作为最常用的数据结构，其特点是**数据元素之间存在一对一**的线性关系（比如说数组）
2. 线性结构有两种不同的存储结构，即顺序存储结构（数组）和链式存储结构（链表）。顺序存储的线性表称为顺序表，顺序表中的存储元素（地址）是连续的。
3. 链式存储的线性表称为链表，链表中的存储元素（地址）不一定是连续的，元素结点中存放数据元素以及相邻元素的地址信息。
4. 线性结构常见的有：数组、队列、链表和栈

**非线性结构**

非线性结构包括：二维数组，多维数组，广义表，树结构，图结构



### 稀疏sparsearray数组

![image-20210508191334117](/Users/mac/Library/Application Support/typora-user-images/image-20210508191334117.png)



**稀疏数组**	

​	当数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。

**稀疏数组的处理方法是**

1. 记录数组中一共有几行几列，有多少个不同的值
2. 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模。

![image-20210508191803439](/Users/mac/Library/Application Support/typora-user-images/image-20210508191803439.png)

原始的：6行7列  6 x 7 = 42

稀疏数组：9 x 3 = 27(压缩了)

​	第一行：记录有几行几列几个不同的值

​	其余的：记录每一个非零的元素的行列和数据大小



**实际例子**

![image-20210508193322783](/Users/mac/Library/Application Support/typora-user-images/image-20210508193322783.png)

**二维数组转稀疏数组的思路**：

1. 遍历原始二维数组，得到有效数据的个数sum
2. 根据sum就可以创建稀疏数组sparseArr int[sum + ]\[3]
3. 将二维数组的有效数据存入稀疏数组中

**稀疏数组转原始二维数组的思路**

1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的chessArr = int[11] [11]
2. 再读取稀疏数组后几行的数据，并赋给原始的二维数组即可。

**代码实现**

一、原始二维数据转稀疏数组

```java
public class SparseArray {
    public static void main(String[] args) {
        //创建一个原始的二维数组 11 * 11
        //0:表示没有棋子， 1表示黑子 2表示蓝字
        int chessArr1[][] = new int[11][11];
        chessArr1[1][2] = 1;
        chessArr1[2][3] = 2;
        //输出原始的二维数组
        System.out.println("原始的二维数组");
        for(int[] row : chessArr1){
            for(int data:row){
                System.out.printf("%d\t",data);
            }
            System.out.println();
        }

        //将二维数组转换成稀疏数组
        //1、先遍历二维数组，得到非零的数字个数
        int sum = 0;
        for (int i = 0; i < chessArr1.length;i++){
            for (int j = 0;j < chessArr1[0].length;j++){
               if (chessArr1[i][j] != 0){
                   sum++;
               }
            }
        }
        System.out.println("sum = " + sum);

        //创建对应的稀疏数组
        int sparseArr[][] = new int[sum+1][3];
        //将二维数组的有效数据存入稀疏数组中
        //第一行要存行，列，非零值
        sparseArr[0][0] = chessArr1.length;
        sparseArr[0][1] = chessArr1[0].length;
        sparseArr[0][2] = sum;

        int m = 1;
        //找出非零数组是第几行第几列，值是多少
        for (int i = 0; i < chessArr1.length;i++){
            for (int j = 0;j < chessArr1[0].length;j++){
                if (chessArr1[i][j] != 0){
                    sparseArr[m][0] = i;
                    sparseArr[m][1] = j;
                    sparseArr[m][2] = chessArr1[i][j];
                    m++;
                }
            }
        }
        //输出稀疏数组
        System.out.println("稀疏数组为：");
//        for (int i = 0; i < sparseArr.length; i++){
//            for (int j =0; j< sparseArr[0].length; j++){
//                System.out.printf("%d\t",sparseArr[i][j]);
//            }
//            System.out.println();
//        }
        for (int[] row : sparseArr){
            for (int data : row){
                System.out.printf("%d\t",data);
            }
            System.out.println();
        }

    }
}
```

二、将稀疏数组转换成二维数组

```java
int row = sparseArr[0][0];
 int col = sparseArr[0][1];
 int chessArr2[][] = new int[row][col];

 //开始往里面放数据
 for (int h = 1; h < sparseArr[0].length;h++){
     int r = sparseArr[h][0];
     int c = sparseArr[h][1];
     chessArr2[r][c] = sparseArr[h][2];
 }
//遍历二维数组
 System.out.println("----------稀疏数组转化为二维数组----------");
 for (int[] row3 : chessArr2){
     for (int data2 : row3){
         System.out.printf("%d\t",data2);
     }
     System.out.println();
 }
```





### 队列

1. 队列是一个有序列表，可以用数组或是链表来实现
2. 遵循**先进先出**的原则。即：先存入队列的数据，要先取出，后存入的要后取出。
3. 示意图![image-20210508232623457](/Users/mac/Library/Application Support/typora-user-images/image-20210508232623457.png)
4. 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如上图，其中maxSize是该队列的最大容量。
5. 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量front和rear分别记录队列前后端的下标，front会随着数据的输出而改变，而rear会随着数据的输入而改变。



**数组模拟队列**

当我们将数据存储队列时称为“addQueue”,addQueue的处理需要两个步骤，**思路分析**：

1. 将尾指针往后移：rear+1  (条件是front == rear--->空)
2. 若尾指针rear小于队列的最大下标maxSize-1，则将数据存入rear所指的数组元素中，否组无法存入数据。rear == maxSize -1（队列满）



**代码实现**

```java
public class ArrayQueueDemo {
    public static void main(String[] args) {
        //测试
        //创建一个队列
        ArrayQueue queue = new ArrayQueue(3);
        char key = ' ';//接收用户输入
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        //输出一个菜单
        while (loop){
            System.out.println("s(show)：显示队列");
            System.out.println("e(exit)：退出队列");
            System.out.println("a(add)：添加数据到队列");
            System.out.println("g(get)：从队列取出数据");
            System.out.println("h(head)：查看队列头数据");
            key = scanner.next().charAt(0);//接收一个字符
            switch (key){
                case 's':
                    queue.showQueue();
                    break;
                case 'a':
                    System.out.println("输出一个数");
                    int value = scanner.nextInt();
                    queue.addQueue(value);
                    break;
                case 'g':
                    try{
                        int res = queue.getQueue();
                        System.out.printf("取出的数据是%d\n",res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h':   //查看队列头的数据是什么？
                    try{
                        int res = queue.headQueue();
                        System.out.printf("取出队列头的数据是%d\n",res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e':
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出！");
    }

}
class ArrayQueue{
    private int maxSize;//表示队列的最大容量
    private int front;//指向队列头部的前一个位置
    private int rear;//指向队列的尾部，就是最后一个数据的位置
    private int[] arr;//用于存放数据，模拟队列

    //创建一个队列构造器
    public ArrayQueue(int arrMaxSize){
        maxSize = arrMaxSize;
        arr = new int[maxSize];
        front = -1;
        rear = -1;
    }

    //判断队列是否满了
    public boolean isFull(){
        return rear == maxSize -1;
    }
    //判断队列是否为空
    public boolean isEmpty(){
        return rear == front;
    }
    //向队列中添加数据
    public void addQueue(int n){
        if (isFull()){
            System.out.println("队列已经满了，无法添加");
            return;
        }
        rear++;
        arr[rear] = n;
    }
    //从队列中取出数据
    public int getQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列空，不能取数据");
        }
        front++;
        return arr[front];
    }

    //显示队列的所有数据
    public void showQueue(){
        if(isEmpty()){
            System.out.println("队列是空的，没有数据！");
            return;
        }
       for (int i =0;i < arr.length;i++){
           System.out.printf("arr[%d]=%d\n",i,arr[i]);
       }
    }
    //显示队列的头部数据，注意不是取数据
    public int headQueue(){
        //判断是不是空
        if(isEmpty()){
            throw new RuntimeException("队列是空的，没有数据！");
        }
        return arr[front+1];
    }
}
```



**数组模拟环形队列**

思路分析：

1. front变量的含义做一个调整：front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素。front的初始值 = 0
2. rear变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间做出一个约定。rear的初试值 = 0；
3. 当队列满时，条件是（rear + 1） % maxSize == front(满)
4. 当队列为空的条件，rear == front 为空
5. 当我们这样分析，队列中有效数据的个数  (rear + maxSize - front) % maxSize  //rear = 1 front = 0
6. 在原来的代码基础上修改就可以得到环形队列



**代码实现**

```java
public class CircleArrayQueueDemo {
    public static void main(String[] args) {
        System.out.println("测试环形数组！");
        CircleArray queue = new CircleArray(4);//说明设置4，其队列的有效数据最大是3
        char key = ' ';//接收用户输入
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        //输出一个菜单
        while (loop){
            System.out.println("s(show)：显示队列");
            System.out.println("e(exit)：退出队列");
            System.out.println("a(add)：添加数据到队列");
            System.out.println("g(get)：从队列取出数据");
            System.out.println("h(head)：查看队列头数据");
            key = scanner.next().charAt(0);//接收一个字符
            switch (key){
                case 's':
                    queue.showQueue();
                    break;
                case 'a':
                    System.out.println("输入一个数");
                    int value = scanner.nextInt();
                    queue.addQueue(value);
                    break;
                case 'g':
                    try{
                        int res = queue.getQueue();
                        System.out.printf("取出的数据是%d\n",res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h':   //查看队列头的数据是什么？
                    try{
                        int res = queue.headQueue();
                        System.out.printf("取出队列头的数据是%d\n",res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e':
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出！");
    }

}
class CircleArray{
    private int maxSize;
    private int front;
    //front变量的含义做一个调整：front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素。front的初始值 = 0
    private int rear;
    //rear变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间做出一个约定。rear的初试值 = 0；
    private int[] arr;//存放数据

    public CircleArray(int arrMaxSize){
        maxSize = arrMaxSize;
        arr = new int[maxSize];
    }

    //判断队列是否满了
    public boolean isFull(){
        return (rear + 1) % maxSize == front;
    }

    //判断是不是为空
    public boolean isEmpty(){
        return rear == front;
    }
    //添加数据到队列
    public void addQueue(int n){
        //判断队列是否满
        if (isFull()){
            System.out.println("队列已满，不能加数据！");
            return;
        }
        //直接将数据加入
        arr[rear] = n;  //rear初始值就是0
        rear = (rear + 1) % maxSize;
    }
    //取出数据
    public int getQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列空，不能取数据!");
        }
        //这里需要先分析出front是指向队列的第一个元素
        //1、先把front对应的值保留到一个临时变量
        //2、将front后移,考虑取模
        //3、将临时保存的变量返回
        int value = arr[front];
        front = (front + 1) % maxSize;
        return value;
    }
    //显示队列数据
    public void showQueue(){
        if(isEmpty()){
            throw new RuntimeException("队列空，不能取数据!");
        }
        //思路：从front开始遍历，遍历多少个元素
        for(int i = front; i < front + size();i++){
            System.out.printf("arr[%d]=%d\n",i % maxSize,arr[i % maxSize]);
        }
    }

    //求出当前数组的有效数据的大小
    public int size(){
        return (rear + maxSize - front) % maxSize;
    }

    //把头元素打出来
    public int headQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列空，没有数据！");
        }
        return arr[front];
    }
}
```





### 链表（Linked List）

链表是有序的列表，但是它在内存中是存储如下：链式存储的，每一个结点并不是连续存储的

![image-20210510110116870](/Users/mac/Library/Application Support/typora-user-images/image-20210510110116870.png)

小结：

1. 链表是以结点的方式来存储的，链式存储的。
2. 每个结点包含data域，next域：指向下一个结点。
3. 如图：发现链表的各个结点不一定是连续存储的（指的是地址不一定是连续的）
4. 链表分为：带头结点的链表和没有头结点的链表，根据实际的需求来确定。



单链表（带头结点）逻辑结构示意图如下：

![image-20210510110824066](/Users/mac/Library/Application Support/typora-user-images/image-20210510110824066.png)



单链表的创建（添加）示意图，显示单向链表的分析：

添加（创建）：

1. 先创建一个head头结点，作用就是表示单链表的头
2. 后面我们每添加一个结点，就直接加入到链表的最后

遍历：

1. 通过一个辅助变量，帮助遍历整个单链表



**需要按照编号的顺序添加**

1. 首先找到新添加结点的位置，是通过辅助变量（指针），通过遍历搞定
2. 新的结点.next = temp.next
3. 将temp.next = 新的结点

**删除结点**

1. 我们先找到要删除结点的前一个结点temp
2. temp.next = temp.next.next
3. 被删除的结点，将不会有其他引用指向，会被垃圾回收机制回收。

**代码实现**

```java
public class SingleLinkedListDemo {
    public static void main(String[] args) {
        HeroNode hero1 = new HeroNode(1,"宋江","及时雨");
        HeroNode hero2 = new HeroNode(2,"卢俊义","玉麒麟");
        HeroNode hero3 = new HeroNode(3,"吴用","智多星");
        HeroNode hero4 = new HeroNode(4,"林冲","豹子头");
        //创建单向链表
        SingleLinkedList singleLinkedList = new SingleLinkedList();
        //加入
//        singleLinkedList.add(hero1);
//        singleLinkedList.add(hero2);
//        singleLinkedList.add(hero3);
//        singleLinkedList.add(hero4);

        //第二种加入
        singleLinkedList.addByOrder(hero1);
        singleLinkedList.addByOrder(hero4);
        singleLinkedList.addByOrder(hero3);
        singleLinkedList.addByOrder(hero2);
        //显示一下
        singleLinkedList.list();

        System.out.println("----------------修改过后的结果----------------");
        HeroNode newHero = new HeroNode(9, "小卢", "玉麒麟~~");
        singleLinkedList.update(newHero);
        singleLinkedList.list();

        singleLinkedList.delete(1);
        singleLinkedList.delete(4);
        singleLinkedList.delete(2);
        singleLinkedList.delete(3);
        System.out.println("----------------修改过后的结果----------------");
        singleLinkedList.list();

    }

}

//创建一个LinkedList链表
class SingleLinkedList{
    //先初始化一个头结点，头结点不要动,不存放具体的数据
    private HeroNode head = new HeroNode(0,"","");

    //添加的方法,添加结点到单向链表中
    //思路：当不考虑编号的顺序时
    //找到当前链表的最后一个结点
    //将最后一个结点的next指向新的结点
    public void add(HeroNode heroNode){
        //因为head结点不能动，因此需要一个辅助变量temp
        HeroNode temp = head;
        //遍历链表，找到最后一个结点
        while (true){
            //最后一个结点
            if (temp.next == null){
                break;
            }
            //如果没有找到最后,temp往后移
            temp = temp.next;
        }
        //当退出循环的时候，temp就指向链表的最后了
        temp.next = heroNode;
    }

    //第二种添加方式，根据排名插入到指定的位置
    public void addByOrder(HeroNode heroNode){
        //因为头结点不能动，因此通过一个辅助指针来帮助找到位置
        //因为单链表，我们找到的temp是位于添加位置的前一个结点，否则插入不了
        HeroNode temp = head;
        boolean flag = false;//flag表示添加的编号是否存在，默认为false
        while (true){
            if (temp.next == null){//最后一个结点了
                break;
            }
            if (temp.next.no > heroNode.no){//位置找到
                break;
            }else if (temp.next.no == heroNode.no){//说明希望添加的编号已经存在了
            flag = true;//说明编号存在了
            break;
            }
            temp = temp.next;//后移，遍历当前链表
        }
        //判断flag
        if (flag){
            System.out.printf("当添加的编号%d以及存在，添加失败\n",heroNode.no);
        }else {//插入到链表当中，temp后面
            heroNode.next = temp.next;
            temp.next = heroNode;
        }

    }

    //修改结点的信息，根据no编号来修改，即no不能变
    public void update(HeroNode newHeroNode){
        //判断是否为空
        if(head.next == null){
            System.out.println("链表为空！");
        }
        //找到需要修改的结点，根据no编号
        //定义一个辅助变量
        HeroNode temp = head.next;
        boolean flag = false;//表示是否找到该结点
        while (true){
            if (temp == null){
                //已经遍历完链表了
                break;
            }
            if (temp.no == newHeroNode.no){//找到了
                flag = true;
                break;
            }
            temp = temp.next;
        }
        //判断找到没有
        if(flag){
            temp.name = newHeroNode.name;
            temp.nickName = newHeroNode.nickName;
        }else {
            System.out.printf("没有找到编号%d的结点信息\n",newHeroNode.no);
        }
    }

    //删除结点
    //head结点不能动
    public void delete(int no){
        HeroNode temp = head;
        //判断链式是不是空的


        boolean flag = false;
        while (true){
            if (temp.next == null){
                System.out.println("链表到最后了，不能删除!");
                break;
            }
            if(temp.next.no == no){//找到了
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag){
            temp.next = temp.next.next;
        }else {
            System.out.printf("要删除的%d结点不存在",no);
        }
    }

    //显示链表，遍历
    public void list(){
        if (head.next == null){//判断链表是否为空
            System.out.println("链表为空！");
        }
        //头结点不能动,因此需要一个辅助结点来遍历
        HeroNode temp = head.next;
        while (true){
            if (temp == null){
                break;
            }
            //输出结点的信息
            System.out.println(temp);
            temp = temp.next;
        }

    }

}
class HeroNode{
    //基本属性
    public int no;
    public String name;
    public String nickName;
    public HeroNode next;
    //构造器
    public HeroNode(int hNo, String hName, String hNickName){
        this.no = hNo;
        this.name = hName;
        this.nickName = hNickName;
    }
    //重写toString方法
    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickName='" + nickName + '\'' +
                '}';
    }
}
```

 **单链表面试题（新浪，百度，腾讯）**

单链表的常见面试题有如下：

1. 求单链表中的有效结点的个数

   ```java
   public static int getLength(HeroNode head){
       if (head.next == null){
           //这是一个空结点
           return 0;
       }
       int length = 0;
       HeroNode temp = head.next;
       while (temp != null){
           length++;
           temp = temp.next;
       }
       return length;
   }
   ```

2. 查找单链表中的倒数第k个结点（新浪）

   ```java
   public static HeroNode findLastIndexHero(HeroNode head,int index){
       if (head.next == null){
           System.out.println("链表为空，无法查找");
       }
       HeroNode temp = head.next;
       //先找到一共几个结点
       int k = 1;
       while (temp != null){
           temp = temp.next;
           k++;
       }
       //先做一个数据的校验
       if (index <= 0 ||index > k){
           return null;
       }
       //找出正数的第（k-index）结点就是要找的
       int m = 1;
       HeroNode temp1 = head.next;
       while (m != (k-index)){
           temp1 = temp1.next;
           m++;
       }
       return temp1;
   }
   ```

3. 单链表的反转（腾讯）

   思路分析：

   1. 先定义一个新的结点reverseHead = new HeroNode();

   2. 从头到尾遍历原理的链表，每遍历一个结点，就将其取出，并放在新的链表的最前端。

   3. 把head结点指向最后加入的那个结点。head.next = reverseHead.next

      ```java
      //单链表的反转（腾讯）
      public static void reverseLinkedList(HeroNode head){
          if(head.next == null|| head.next.next == null){
              System.out.println("无需反转");
              return;
          }
          //定义一个辅助的指针，帮助遍历原来的链表
          HeroNode curr = head.next;
          HeroNode next = null;//指向当前结点的下一个结点
          //先创建一个新的链表
          HeroNode reverseHead = new HeroNode(0,"","");
          //遍历传进来的链表，每取出来一个就把它放到新链表的最前面
          while (curr != null){
              next = curr.next;//先暂时保留当前结点的下一个结点
              curr.next = reverseHead.next;
              reverseHead.next = curr;    //将curr加到新的链表上
              curr = next;
          }
          //将head.next指向reverseHead.next
          head.next = reverseHead.next;
      }
      ```

4. 从尾到头打印单链表（百度：要求方式1：反向遍历。方式2：Stack栈）

   思路分析：

   1. 上面的题目要求，就是逆序打印单链表

   2. 方式1：现将单链表反转，然后遍历即可，这样做的问题是：会破坏原来单链表的结构，不建议这样操作。

   3. 方式2：利用栈这个数据结构，将各个结点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果。使用stack集合

      ```java
      public static void reversePrint(HeroNode head){
          if (head.next == null){
              return;
          }
          Stack<HeroNode> stack = new Stack<HeroNode>();
          HeroNode cur = head.next;
          //将链表的所有结点压如栈中
          while (cur != null){
              stack.push(cur);
              cur = cur.next;
          }
          while (stack.size() > 0){
              System.out.println(stack.pop());
          }
      }
      ```

5. 合并两个有序的单链表，合并之后的单链表依然有序。

   思路分析：

   首先分析合并两个链表的过程。我们的分析从合并两个链表的头结点开始。链表1的头结点的值小于链表2的头结点的值，因此链表1的头结点将是合并后链表的头结点，如图所示：

   

![这里写图片描述](https://img-blog.csdn.net/20150801211838520?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

我们继续合并两个链表中剩余的结点。在两个链表中剩下的结点依然是排序的，因此合并这两个链表的步骤和前面的步骤是一样的。我们还是比较两个头结点的值。此时链表2的头结点的值小于链表1的头结点的值，因此链表2的头结点的值将是合并剩余结点得到的链表的头结点。我们把这个结点和前面合并链表时得到的链表的尾结点链接起来，如图所示。
当我们得到两个链表中值较小的头结点并把它链接到已经合并的链表之后，两个链表剩余的结点依然是排序的，因此合并的步骤和之前的步骤是一样的。这就是典型的递归的过程。

**代码实现**

```java
public static HeroNode mergeLists(HeroNode list1,HeroNode list2){
    if (list1 == null){
        return list2;
    }else if(list2 == null){
        return list1;
    }

    HeroNode newHead = null;
    if (list1.no < list2.no){
        newHead = list1;
        newHead.next = mergeLists(list1.next,list2);
    }else {
        newHead = list2;
        newHead.next = mergeLists(list2.next,list1);
    }
    return newHead;
}
```



### 双向链表

单向链表的缺点：

1. 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。
2. 单向链表不能自我删除，需要依靠辅助结点，而双向链表，则可以自我删除，所以前面单向链表删除结点时，总是找到temp，temp是待删除结点的前一个结点。

**分析双向链表的遍历，添加，删除的操作思路**

![image-20210511211055931](/Users/mac/Library/Application Support/typora-user-images/image-20210511211055931.png)

1. 遍历和单向链表一样，只是可以向前，也可以向后查找
2. 添加（默认加到双向链表的最后）
   1. 先找到双向链表的最后一个结点
   2. temp.next = newHeroNode
   3. newHeroNode.pre = temp
3. 修改和单向链表的思路一样
4. 删除
   1. 因为是双向链表，因此，可以实现自我删除某个结点
   2. 直接找到要删除的结点，比如temp
   3. temp.pre.next = temp.next
   4. temp.next.pre = temp.pre

### 单向环形链表应用场景(约瑟夫问题)

Josephu（约瑟夫环，约瑟夫环）问题

![image-20210512164740257](/Users/mac/Library/Application Support/typora-user-images/image-20210512164740257.png)

​													丢手绢问题

Josephu问题为：设编号为1,2,...,n的n个人围坐在一圈，约定编号为k（1<=k<=n）的人从1开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，以此类推，直到所有人出列为止，有此产生一个出队编号的序列。

**提示**：用一个不带头结点的循环链表来处理Josephu问题，先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中被删除，算法结束。



**单向环形链表**

![image-20210512164905850](/Users/mac/Library/Application Support/typora-user-images/image-20210512164905850.png)

**约瑟夫问题示意图**

设：n = 5 ，即有五个人

​		k = 1,从第一个人开始报数

​		m = 2,数两下

![image-20210512165342194](/Users/mac/Library/Application Support/typora-user-images/image-20210512165342194.png)

出圈的顺序推演为：2->4->1->-5->3

**构建一个单向环形链表的思路**

1. 先创建第一个结点，让first指向该结点，并形成环形
2. 后面当我们每创建一个新的结点，就把该结点，加入到已有的环形链表中即可。

**遍历**

1. 先让一个辅助指针（变量），指向first结点
2. 然后通过一个while循环遍历环形链表即可，currBoy.next = first结束

**约瑟夫问题的实现**

1. 需要创建一个辅助指针（变量）helper，事先应该指向环形链表的最后这个结点
2. 报数前，先让first和helper移动k-1次，就是移动到k那个位置
3. 当小孩报数的前，让first和helper指针同时移动m-1次
4. 这时就可以将first指向的小孩结点出圈  first = first.next    helper.next = first 原来first指向的结点就没有任何引用，就会被回收。

**代码实现**

```java
/**
 * @param startNo  表示从第几个小孩开始数
 * @param countNum 表示数几下
 * @param nums     表示最初有多少小孩在圈中
 */
public void countBoy(int startNo, int countNum, int nums) {
    //数据校验
    if (first == null || startNo < 1 || startNo > nums) {
        System.out.println("数据输入有误，请重新输入！");
        return;//直接退出不玩了
    }
    //先创建一个辅助指针,放到first后面
    Boy helper = first;
    while (true) {
        if (helper.getNext() == first) {//说明helper指向最后小孩结点
            break;
        }
        helper = helper.getNext();
    }
    //小孩报数前，先让helper和first移动到要报数的地方,移动startNo -1 下
    for (int i = 0; i < startNo - 1; i++) {
        first = first.getNext();
        helper = helper.getNext();
    }
    //退出循环的时候，说明已经到达地方了
    //开始报数，移动countNum - 1 次，出圈
    while (true) {
        if (helper == first) {//说明已经到最后，剩下一个小孩了
            break;
        }
        for (int j = 0; j < countNum - 1; j++) {
            first = first.getNext();
            helper = helper.getNext();
        }
        //退出遍历，说明找到地方了，现在让小孩出圈
        System.out.printf("第%d个小孩出圈\n", first.getNo());
        //出圈
        first = first.getNext();
        helper.setNext(first);
    }
    //退出循环的时候，说明圈子里还剩下最后一个小孩
    System.out.printf("最后一个小孩%d还在圈中", helper.getNo());
}
```



### 栈(Stack)

栈的实际需求：

请输入一个表达式：计算式：7 * 7 * 7 - 5 + 1 -5 +3 -3 点击计算

请问：计算机底层是如何运算得到结果的？注意不是简单的把算式列出运算，因为对计算机而言，它接收到的就是一个字符串。String str = "7 * 7 * 7 - 5 + 1 -5 +3 -3 "

**栈的介绍**

1. 栈的英文是stack

2. 栈是一个先进后出的有序列表

3. 栈是限制线性表中元素插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶（Top），另一端固定的一端，称为栈底（Bottom）.

4. 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除。

5. 出栈(pop)和入栈(push)的概念

   **栈的应用场景**

   1. 子程序调用：在跳往子程序前，会先将下一个指令的地址放入堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。
   2. 处理递归调用：和子程序调用类似，只是除了存储下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。
   3. 表达式的转换（中缀表达式转后缀表达式）与求值（实际解决）
   4. 二叉树的遍历
   5. 图形的深度优先（depth-first）搜索法

**数组模拟栈的思路分析**

1. 使用数字模拟栈
2. 定义一个变量top表示栈顶，初始化为-1
3. 入栈的操作，当有数据加入到栈的时候，top++，stack[top] = data;
4. 出栈的操作，int value = stack[top];top--,return value;

**代码实现**

```java
//定义一个ArrayStack 表示栈
class ArrayStack {
    private int maxSize;//栈的大小
    private int[] stack;//数组，模拟栈
    private int top = -1;//表示栈顶，初始化为-1
    //构造器
    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }
    //判断栈满
    public boolean isFull() {
        return top == maxSize - 1;
    }
    //判断栈空
    public boolean isEmpty() {
        return top == -1;
    }
    //入栈
    public void push(int value) {
        if (isFull()) {
            System.out.println("栈已满，无法入栈！");
            return;
        }
        top++;
        stack[top] = value;
    }
    //出栈
    public int pop() {
        if (isEmpty()) {
            throw new RuntimeException("栈为空，无法出栈！");
        }
        int value = stack[top];
        top--;
        return value;
    }
    //显示栈的情况（遍历栈）
    public void list() {
        if (isEmpty()) {
            System.out.println("栈空，没有数据！");
            return;
        }
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d] = %d\n", i, stack[i]);
        }
    }
}
```



**链表模拟**

**栈实现综合计算器**

使用栈完成表达式计算的思路

![image-20210519192704545](/Users/mac/Library/Application Support/typora-user-images/image-20210519192704545.png)

1. 通过一个index值（索引），来遍历我们的表达式

2. 如果我们发现是一个数字，就直接入数栈

3. 如果发现扫描到的是一个符号，就分如下情况解决

   3.1如果发现当前的符号栈为空，就直接入栈

   3.2如果符号栈有操作符，就进行比较，**如果当前的操作符的优先级小于或者等于栈中的操作符**，就需要从数栈中pop出两个数，在符号栈中pop出一个符号，进行运算，将得到的结果，入数栈，然后将当前的操作符入符号栈。**如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈**

4. 当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行

5. 最后在数栈中只有一个数字，就是表达式的结果

**代码实现**

```java
public class Calculator {
    public static void main(String[] args) {
        //完成表达式的运算
        String expression = "90+2*6-2";
        //创建两个栈，一个数栈，一个符号栈
        ArrayStack2 numStack = new ArrayStack2(10);
        ArrayStack2 operStack = new ArrayStack2(10);
        //初始化遍历
        int index = 0;
        int num1 = 0;
        int num2 = 0;
        int res = 0;
        int oper = 0;
        char ch = ' ';//将每次扫描得到的char保存到ch
        String keepNum = "";
        //开始while循环的扫描expression
        while (true) {
            //依次得到每一个字符
            ch = expression.substring(index, index + 1).charAt(0);
            //判断ch是什么数还是符号
            if (operStack.isOper(ch)) {//如果是符号的话，分两种情况入栈
                if (!operStack.isEmpty()) {
                    if (operStack.priority(ch) <= operStack.priority(operStack.peak())) {
                        num1 = numStack.pop();
                        num2 = numStack.pop();
                        oper = operStack.pop();
                        res = operStack.cal(num1, num2, oper);
                        //将得到的结果，入数栈，然后将当前的操作符入符号栈。
                        numStack.push(res);
                        operStack.push(ch);
                    } else {
                        operStack.push(ch);
                    }
                } else {//如果当前符号栈是空的，直接入栈
                    operStack.push(ch);

                }
            } else {//是数字，直接入栈
//                numStack.push(ch - 48);
                //分析思路:
                //1.当处理多位数的时候，不能发现一个数就立即入栈，因为他可能是多位数
                //2、在处理数，需要向expression表达式的index后再看一位，如果是数就进行扫描，如果是符号才入栈
                //3、因此我们需要定义一个变量字符串，用于拼接
                keepNum += ch;
                //判断是不是到最后一位了
                if (index == expression.length() - 1) {
                    numStack.push(Integer.parseInt(keepNum));
                }else {
                    if (operStack.isOper(expression.substring(index+1,index+2).charAt(0))){
                        //如果最后一位是运算符，则入栈keepNum = "1" 或者"123"
                        numStack.push(Integer.parseInt(keepNum));
                        keepNum = "";
                    }
                }


            }
            index++;
            if (index >= expression.length()) {
                break;
            }
        }
        //表达式扫描完毕，顺序的从数栈和符号栈中pop出相应的数字和符号，并运行
        while (true) {
            if (operStack.isEmpty()) {
                //如果符号栈为空，说明计算结束了
                break;
            }
            num1 = numStack.pop();
            num2 = numStack.pop();
            oper = operStack.pop();
            res = operStack.cal(num1, num2, oper);
            numStack.push(res);
        }
        //打印结果
        System.out.printf("表达式 %s = %d", expression, numStack.pop());


    }
}

class ArrayStack2 {
    private int maxSize;//栈的大小
    private int[] stack;//数组，模拟栈
    private int top = -1;//表示栈顶，初始化为-1

    //构造器
    public ArrayStack2(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }

    //返回当前栈顶值，但不是真正的pop
    public int peak() {
        return stack[top];
    }

    //判断栈满
    public boolean isFull() {
        return top == maxSize - 1;
    }

    //判断栈空
    public boolean isEmpty() {
        return top == -1;
    }

    //入栈
    public void push(int value) {
        if (isFull()) {
            System.out.println("栈已满，无法入栈！");
            return;
        }
        top++;
        stack[top] = value;
    }

    //出栈
    public int pop() {
        if (isEmpty()) {
            throw new RuntimeException("栈为空，无法出栈！");
        }
        int value = stack[top];
        top--;
        return value;
    }

    //显示栈的情况（遍历栈）
    public void list() {
        if (isEmpty()) {
            System.out.println("栈空，没有数据！");
            return;
        }
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d] = %d\n", i, stack[i]);
        }
    }

    //返回运算符的优先级，优先级是程序员定的，优先级使用数字表示
    //数字越大，则优先级就越高
    public int priority(int oper) {
        if (oper == '*' || oper == '/') {
            return 1;
        } else if (oper == '+' || oper == '-') {
            return 0;
        } else {
            return -1;
        }
    }

    //判断是不是运算符
    public boolean isOper(char val) {
        return val == '+' || val == '-' || val == '*' || val == '/';
    }

    //计算方法
    public int cal(int num1, int num2, int oper) {
        //假定结果返回的是res
        int res = 0;
        switch (oper) {
            case '+':
                res = num1 + num2;
                break;
            case '-':
                res = num2 - num1;
                break;
            case '*':
                res = num1 * num2;
                break;
            case '/':
                res = num2 / num1;
                break;
            default:
                break;
        }
        return res;
    }
}
```





**前缀、中缀、后缀表达式（逆波兰表达式）**

**前缀表达式**（逆波兰表达式）

1. 前缀表达式又称为波兰表达式，前缀表达式的运算符位于操作数之前
2. 举例说明：(3+4)*5-6对应的前缀表达式就是    - x + 3 4 5 6

前缀表达式的计算机求值

从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对他们做相应的计算（栈顶元素和次顶元素），并将结果入栈；重读上述过程直到表达式最左端，最后原酸得出的值即为表达式的结果

例如：(3+4)*5-6对应的前缀表达式就是- x + 3 4 5 6，针对前缀表达式求值的步骤如下：

1. 从右至左扫描，将6、5、4、3压入堆栈
2. 遇到加运算符，因此弹出3和4（3位栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈
3. 接下来是*运算符，因此弹出7和5，计算出7*x5=35，将35入栈
4. 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。



**中缀表达式**

1. 中缀表达式就是常见的运算表达式，
2. 中缀表达式是人类熟悉的，但是计算机不熟悉的



**后缀表达式**

1. 后缀表达式又称为逆波兰表达式，与前缀表达式相似，只是运算符位于操作数之后
2. 举例说明 (3+4)*5-6 对应的后缀表达式就是 3 4  + 5 * 6 -
3. 再比如：

![image-20210520150255760](/Users/mac/Library/Application Support/typora-user-images/image-20210520150255760.png)

后缀表达式的计算机求值

从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做出相应的计算（次顶元素和栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果



例如：(3+4)*5-6 对应的后缀表达式就是3 4 + 5 x 6 -，针对后缀表达式求值步骤如下：

1. 从左至右扫描，将对应3和4压入堆栈
2. 遇到+运算符，因此弹出4和3（4位栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
3. 将5入栈
4. 接下来是x运算符，因此弹出5和7，计算出7 x 5 = 35，将35入栈
5. 将6入栈
6. 最后是-运算符，计算出35-6的值，即29，由此得出最终结果



**逆波兰计算器**

我们完成一个逆波兰计算器，要求完成如下任务

1. 输入一个逆波兰表达式，谁用栈（Stack）计算出结果
2. 支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算
3. 思路分析
4. 代码完成

**代码实现**

```java
public class PolandNotation {
    public static void main(String[] args) {
        //先定义一个逆波兰表达式
        //(3+4)*5-6
//        String suffixExpression = "3 4 + 5 * 6 -";
        //(30+4)*5-6 = 164
        String suffixExpression = "30 4 + 5 * 6 -";
        //测试一把转换
        List<String> res = getListString(suffixExpression);
        System.out.println(res);

        int val = calculator(res);
        System.out.println("计算的结果是：" + val);

    }

    //将一个逆波兰表达式，依次将数据和运算符放入到ArrayList中
public static List<String> getListString(String suffixExpression){
        //先用正则表达式分割字符串
    String[] split = suffixExpression.split(" ");
    ArrayList<String> list = new ArrayList<>();
    //把字符串放到一个ArrayList中
    for (String ele:split){
        list.add(ele);
    }
    return list;
}

    //完成对波兰表达式计算
    /**
     1. 从左至右扫描，将对应3和4压入堆栈
     2. 遇到+运算符，因此弹出4和3（4位栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
     3. 将5入栈
     4. 接下来是x运算符，因此弹出5和7，计算出7 x 5 = 35，将35入栈
     5. 将6入栈
     6. 最后是-运算符，计算出35-6的值，即29，由此得出最终结果
     */
    public static int calculator(List<String> list){
        //创建一个栈
        Stack<String> stack = new Stack<>();
        //遍历list
        for (String item:list){
            //这里使用正则表达式取数
            if(item.matches("\\d+")){//匹配的多位数
                //入栈
                stack.push(item);
            }else {
                //pop出两个数,并运算，再入栈
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int res = 0;
                //判断这里的运算符是什么
                if (item.equals("+")){
                    res = num1 + num2;
                }else if(item.equals("-")){
                    res = num1 - num2;
                }else if(item.equals("*")){
                    res = num1 * num2;
                }else if(item.equals("/")){
                    res = num1 / num2;
                }else {
                    throw new RuntimeException("您的输入有误，请重新输入！");
                }
                //将运算的结果压入栈中
                stack.push("" + res);
            }
        }
        return Integer.parseInt(stack.pop());
    }
}
```



**中缀转后缀表达式**

具体步骤如下：

1. 初始化两个栈：运算符栈s1和存储中间结果的栈s2
2. 从左至右扫描中缀表达式
3. 遇到操作数时，将其压入s2
4. 遇到运算符时，比较其与s1栈顶运算符的优先级：
   1. 如果s1为空，或栈顶运算符为左括号“（”，则直接将此运算符入栈；
   2. 否则，若优先级比栈顶运算符的高，也将运算符压入s1;
   3. 否则，将s1栈顶运算符弹出并压入到s2中，再次转到（4-1）与s1中新的栈顶运算符相比较；
5. 如果遇到括号时：
   1. 如果是左括号“（”，则直接压入s1
   2. 如果是右括号“）”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃。
6. 重复步骤2至5，直到表达式的最右边
7. 将s1中剩余的运算符依次弹出并压入s2
8. 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式。



举例：中缀表达式：1 + ( ( 2+3 ) ) x 4 - 5  ----->后缀表达式

![image-20210520205959196](/Users/mac/Library/Application Support/typora-user-images/image-20210520205959196.png)



**代码实现**

```java
public static List<String> parseSuffixExpression(List<String> ls) {
    //定义两个栈
    Stack<String> s1 = new Stack<String>();//符号栈
    ArrayList<String> s2 = new ArrayList<String>();//数栈
    //遍历传进来的List
    for (String item : ls) {
        if (item.matches("\\d+")) {//如果item是一个数加入s2
            s2.add(item);
        } else if (item.equals("(")) {//如果遇到的是左括号，直接压入s1
            s1.push(item);
        } else if (item.equals(")")) {//如果遇到的是右括号
            //则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
            while (!s1.peek().equals("(")) {
                s2.add(s1.pop());
            }
            s1.pop();
        } else {//如果遇到的是运算符，比较其于s1栈顶运算符的优先级
            while (s1.size() != 0 && Operation.getValue(s1.peek()) >= Operation.getValue(item)) {
                s2.add(s1.pop());
            }
            //还需要将item压入栈中
            s1.push(item);

        }

    }
    while (s1.size() != 0) {
        s2.add(s1.pop());
    }
    return s2;
}
```



### 哈希表

google一个上机题：

有一个公司，当有新员工来报道时，要求将该员工的信息加入（id,性别，年龄，住址），当输入该员工的id时，要求查找到该员工的所有信息



要求：不使用数据库，尽量节省内存，速度越快越好=>哈希表（散列）



**散列表**：（Hash table,也叫哈希表）是根据关键码值（Key Value）**而直接进行访问的数据结构**，也就是说，它通过把关键码值映射到一个表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做：**散列函数**，存放记录的数组叫做**散列表**

![image-20210607173143504](/Users/mac/Library/Application Support/typora-user-images/image-20210607173143504.png)



哈希表的结构：

![image-20210607173207338](/Users/mac/Library/Application Support/typora-user-images/image-20210607173207338.png)

![image-20210607190929232](/Users/mac/Library/Application Support/typora-user-images/image-20210607190929232.png)

哈希表里面放的是数组，数组里面的每一个元素是一个链表（头），指向的是雇员信息。



**代码实现**

```java
//编写HashTab 管理多条链表
class HashTab {
    private EmpLinkedList[] empLinkedListArray;
    private int size;

    public HashTab(int size) {
        this.empLinkedListArray = new EmpLinkedList[size];
        //这里不要忘了初始化每一条链表
        for (int i = 0; i < size; i++) {
            empLinkedListArray[i] = new EmpLinkedList();
        }
        this.size = size;
    }

    //遍历HashTab
    public void list() {
        for (int i = 0; i < size; i++) {
            empLinkedListArray[i].list(i);
        }
    }

    //添加元素的方法
    public void add(Emp emp) {
        int empLinkedListNo = hashFun(emp.id);
        empLinkedListArray[empLinkedListNo].add(emp);
    }

    //散列函数
    public int hashFun(int id) {
        return id % size;
    }

    //根据输入的id查找雇员
    public void findById(int id) {
        int empLinkedListNo = hashFun(id);
        Emp emp = empLinkedListArray[empLinkedListNo].findEmpById(id);
        if (emp != null) {//找到了
            System.out.printf("在第%d条链表中找到雇员 id = %d/n",empLinkedListNo + 1,id);
        }else {
            System.out.println("在哈希表中，没有找到该雇员");
        }
    }

}

//创建一个雇员
class Emp {
    public int id;
    public String name;
    public Emp next;

    public Emp(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

//创建一个EmpLinkedList
class EmpLinkedList {
    //头指针
    private Emp head;//默认为null

    //添加雇员方法
    public void add(Emp emp) {
        if (head == null) {
            head = emp;
            return;
        }
        //如果不是第一个雇员，遍历一下，找到最后一个结点，放到最后
        Emp temp = head;
        while (true) {
            if (temp.next == null) {//temp就是最后一个
                break;
            }
            temp = temp.next;
        }//退出的时候添加进去
        temp.next = emp;
    }

    //遍历链表
    public void list(int no) {
        if (head == null) {
            System.out.println("第" + (no + 1) + "条链表:");
            return;
        }
        Emp temp = head;
        System.out.print("第" + (no + 1) + "条链表信息为:");
        while (true) {
            System.out.printf("=> id = %d name = %s\t", temp.id, temp.name);
            if (temp.next == null) {
                break;
            }
            temp = temp.next;
        }
        System.out.println();
    }

    //查找雇员的方法
    public Emp findEmpById(int id) {
        //判断链表是否为空
        if (head == null) {
            System.out.println("链表为空！");
            return null;
        }
        //辅助指针
        Emp curEmp = head;
        while (true) {
            if (curEmp.id == id) {//找到了
                break;//这时curTemp就指向要查找的雇员
            }
            //退出
            if (curEmp.next == null) {//说明遍历完毕都没有找到该雇员
                curEmp = null;
                break;
            }
            curEmp = curEmp.next;
        }
        return curEmp;
    }
}
```



### 树结构（基础）

**为什么需要树结构**

1. 数组存储方式的分析

   优点：通过下标方式访问元素，速度快。**对于有序数组**，还可以使用二分查找提高检索速度。

   缺点：如果要检索具体某个值，或者插入值（按一定顺序）会整体移动，效率较低（实现分配好了空间，要数组扩容，在底层需要创建新的数组，要将原来的数据拷贝到新数组）

2. 链式存储方式的分析：

   优点：在一定程度上对数组存储方式有优化（比如：插入一个数值结点，只需要将插入结点，连接到链表中即可，删除效率也比较高）

3. 树存储方式的分析

   能提高数据存储，读取的效率，比如利用二叉树排序（Binary Sort Tree）,既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。

   缺点：在进行检索的时候，效率仍然较低，比如：检索某个值，需要从头结点开始遍历

   分析：如果以二叉排序树来存储数据，那么对数据的增删改查的效率都可以提高

   例如：[7,3,10,1,5,9,12]

   ![image-20210607213900576](/Users/mac/Library/Application Support/typora-user-images/image-20210607213900576.png)

分析一下二叉排序树来存储的效率

1、查找12，经过两次比较久找到12结点

2、添加，也很快

3、删除效率也很高

**树的常用术语**

1. 结点
2. 根结点
3. 父结点
4. 子结点
5. 叶子结点（没有子结点的结点）
6. 结点的权（结点值）
7. 路径（从根结点找到该结点的路线）
8. 层
9. 子树
10. 树的高度：最大层数
11. 森林：多颗子树构成森林

**二叉树**

1. 树有很多种，每个结点**最多只能有两个子结点**的一种形式成为二叉树
2. 二叉树的子结点分为左结点和右结点
3. 如果该二叉树的所有叶子结点都在最后一层，并且结点总数=2^n-1，n为层数，则我们称为满二叉树。
4. 如果该二叉树的所有叶子结点都在最后一层或者倒数第二层。而且最后一层的叶子结点在左边连续，倒数第二层的叶子结点在右边连续，我们称为完全二叉树。
5. ![image-20210608103248484](/Users/mac/Library/Application Support/typora-user-images/image-20210608103248484.png)





二叉树的遍历方式：

前序遍历：**先输出父结点**，再遍历左子树和右子树

中序遍历：先遍历左子树，**再输出父结点**，再遍历出父结点

后序遍历：先遍历左子树，再遍历右子树，**最后输出父结点**

**小结**：看输出父结点的顺序，就确定是前序，中序和后序

![image-20210608142357033](/Users/mac/Library/Application Support/typora-user-images/image-20210608142357033.png)



分析二叉树的前序，中序，后序的遍历步骤：

1. 创建一颗二叉树

2. 前序遍历：

   2.1先输出当前结点（初始的时候是根结点）

   2.2如果左子结点不为空，则递归继续前序遍历

   2.3如果右子结点不为空，则递归继续前序遍历

3. 中序遍历：

   3.1如果当前结点的左子结点不为空，则递归中序遍历，先输出当前结点（初始的时候是根结点）

   3.2输出当前结点

   3.3如果当前结点的右子结点不为空，则递归中序遍历

4. 后序遍历：

   4.1如果当前结点的左子结点不为空，则递归后序遍历

   4.2.如果当前结点的右子结点不为空，则递归后序遍历

   4.3输出当前结点



**代码实现**

```java
//先创建HeroNode结点
class HeroNode {
    private int no;
    private String name;
    private HeroNode left;
    private HeroNode right;

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }

    //编写前序遍历的方法
    public void preOrder() {
        System.out.println(this);//先输出父结点
        //递归向左子树前序遍历
        if (this.left != null) {
            this.left.preOrder();
        }
        //递归向右子树前序遍历
        if (this.right != null) {
            this.right.preOrder();
        }
    }

    //编写中序遍历的方法
    public void infixOrder() {
        //递归想左子树中序遍历
        if (this.left != null) {
            this.left.infixOrder();
        }
        //输出父结点
        System.out.println(this);
        //递归向右子树中序遍历
        if (this.right != null) {
            this.right.infixOrder();
        }
    }

    //编写后序遍历的方法
    public void postOrder() {
        //先向左子树递归后序遍历
        if (this.left != null) {
            this.left.postOrder();
        }
        //向右子树递归后序遍历
        if (this.right != null) {
            this.right.postOrder();
        }
        //输出当前结点
        System.out.println(this);

    }
}
```

```java
//定义一个二叉树
class BinaryTree {
    private HeroNode root;

    public void setRoot(HeroNode root) {
        this.root = root;
    }

    //前序遍历
    public void preOrder() {
        if (this.root != null) {
            this.root.preOrder();
        } else {
            System.out.println("二叉树为空，无法遍历！");
        }
    }

    //中序遍历
    public void infixOrder() {
        if (this.root != null) {
            this.root.infixOrder();
        } else {
            System.out.println("二叉树为空，无法遍历！");
        }
    }
    //后序遍历
    public void postOrder(){
        if (this.root != null) {
        this.root.postOrder();
        }else System.out.println("二叉树为空，");
        }
}
```

```java
public static void main(String[] args) {
    //先需要创建一颗二叉树
    BinaryTree binaryTree = new BinaryTree();
    //创建需要的结点
    HeroNode root = new HeroNode(1, "宋江");
    HeroNode node2 = new HeroNode(2, "吴用");
    HeroNode node3 = new HeroNode(3, "卢俊义");
    HeroNode node4 = new HeroNode(4, "林冲");
    HeroNode node5 = new HeroNode(5, "关胜");

    //手动创建二叉树
    root.setLeft(node2);
    root.setRight(node3);
    node3.setRight(node4);
    node3.setLeft(node5);
    binaryTree.setRoot(root);

    //测试前序遍历
    System.out.println("前序遍历");
    binaryTree.preOrder();  //1-2-3-5-4
    //测试中序遍历
    System.out.println("中序遍历");
    binaryTree.infixOrder();//2-1-5-3-4
    //测试中序遍历
    System.out.println("后序遍历");
    binaryTree.postOrder();//2-5-4-3-1


}
```



**二叉树-查找指定结点**

要求：

1. 请编写前序查找，中序查找和后序查找的方法
2. 并分别使用三种查找方式，查找heroNo = 5的结点
3. 并分析各种查找方式，分别比较了多少次

**思路分析**

前序查找思路：

1. 先判断当前结点no是否等于要查找结点
2. 如果相等，则返回当前结点
3. 如果不等，则判断当前结点的左子结点是否为空，如果不为空，则递归前序查找。
4. 如果左递归前序查找，找到结点则返回，否则继续判断当前结点的右子结点是否为空，如果不为空，则继续向右递归前序查找。

中序查找思路：

1. 判断当前结点的左子结点no是否为空，如果不为空，则递归中序查找
2. 如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点，否则继续向右递归中序查找。
3. 如果右递归中序查找找到就返回，如果没有找到就返回null

后序查找思路：

1. 先判断当前结点的左子结点是否等于要查找的结点，如果不是，则递归后序查找。
2. 如果找到了，就返回，如果没有找到，就和当前结点的右子结点比较是否一样，如果没有找到，就继续向右递归后序查找。
3. 如果找到了就返回，如果没有找到。就和当前结点进行比较，如果等于要找的结点就返回，如果没有就返回null

**代码实现**

```java
//前序遍历查找的方法
public HeroNode preOrderSearch(int no) {
    System.out.println("进入前序遍历！");
    //先判断当前结点的no是否等于要查找的no
    if (this.no == no) {
        return this;
    }
    //定义一个接收结点
    HeroNode resNode = null;
    //如果当前结点不是，那就想左子结点找
    if (this.left != null) {
        resNode = this.left.preOrderSearch(no);
    }
    if (resNode != null) {//左子结点递归查找完了，如果找到，就返回结果
        return resNode;
    }
    //如果左子结点递归查找完了，没有找到，就右递归找
    if (this.right != null) {
        resNode = this.right.preOrderSearch(no);
    }
    return resNode;//不管找没找到，都返回（没找到返回null）
}

//中序遍历查找
public HeroNode infixOrderSearch(int no) {
    HeroNode resNode = null;
    if (this.left != null) {
        resNode = this.left.infixOrderSearch(no);
    }
    if (resNode != null) {
        return resNode;
    }
    System.out.println("进入中序遍历！");
    if (this.no == no) {
        return this;
    }
    if (this.right != null) {
        resNode = this.right.infixOrderSearch(no);
    }
    return resNode;
}

//后序遍历查找
public HeroNode postOrderSearch(int no) {
    HeroNode resNode = null;
    if (this.left != null) {
        resNode = this.left.postOrderSearch(no);
    }
    if (resNode != null) {
        return resNode;
    }
    if (this.right != null) {
        resNode = this.right.postOrderSearch(no);
    }
    if (resNode != null) {
        return resNode;
    }
    System.out.println("进入后序遍历！");
    if (this.no == no) {
        return this;
    }
    return resNode;
}
```



**二叉树删除结点**

要求：（规定）

1. 如果删除的结点是叶子结点（没有子结点的结点），则删除该结点
2. 如果删除的结点是非叶子结点，则删除该子树
3. 测试，删除掉5号字而已结点和3号子树

**删除结点的思路**

1. 还需要考虑，如果根结点本身就是空的情况下，是没有办法删除的，则等价于将二叉树置空。
2. 因为我们的二叉树是单向的，所以我么是判断当前结点的子结点是否需要删除，而不能判断当前结点是不是需要删除的结点。
3. 如果当前结点的左子结点不为空并且左子结点就是要删除的结点，就像this.left = null，并且就结束递归，结束删除任务。
4. 如果当前当前结点的右子结点不为空，并且右子结点就是要删除的结点，就将this.right = null.并且就结束递归，结束删除任务。
5. 如果第2和第3步没有删除结点，那么我们就向左子树进行递归删除。
6. 如果向左子树没有删除成功，我们就需要向右子树继续递归删除。

**代码实现**

```java
//递归删除结点
//1、如果要删除的结点是子叶结点，就删除该结点
//2、如果删除的结点不是叶子结点，就删除该结点的子树
public void delNode(int no) {

    //判断当前结点的左子结点是不是要删除的结点
    if (this.left != null && this.left.no == no) {
        this.left = null;
        return;
    }
    //判断当前结点的左子结点是不是要删除的结点
    if (this.right != null && this.right.no == no) {
        this.right = null;
        return;
    }
    //如果当前结点的左右子结点都不是要删除的结点
    //继续向左子树递归
    if (this.left != null) {
        this.left.delNode(no);
    }
    //左边递归完了，没有找到就向右边递归
    if (this.right != null) {
        this.right.delNode(no);
    }
}
```



二叉树里的方法

```java
//删除结点
public void delNode(int no) {
    if (root != null) {//先判断一下根结点是不是空的
        if (root.getNo() == no){
            root = null;
        }else {
            root.delNode(no);
        }
    } else {//如果跟结点是空的
        System.out.println("根结点为空！");
    }
}
```



**顺序存储二叉树**

基本说明：从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组，看下面的示意图：

![image-20210609095816505](/Users/mac/Library/Application Support/typora-user-images/image-20210609095816505.png)



要求：

1. 上图的二叉树的结点，要求以数组的方式来存放
2. 遍历的时候仍然以树的方式遍历（前序遍历、中序遍历、后序遍历）

**顺序存储二叉树的特点**

1. 顺序二叉树通常只考虑完全二叉树
2. 第n个元素的左子结点为2*n+1
3. 第n个元素的右子结点为2*n+2
4. 第n个元素的父结点为(n-1)/2
5. n表示二叉树中的第几个元素（按0开始编号 ）



**代码实现**

```java
class ArrBinaryTree {
    private int[] arr;

    public ArrBinaryTree(int[] arr) {
        this.arr = arr;
    }
    //重载
    public void preOrder() {
        this.preOrder(0);
    }

    public void infixOrder() {
        this.infixOrder(0);
    }

    public void postOrder(){
        this.postOrder(0);
    }

    //编写一个方法完成顺序存储二叉树
    public void preOrder(int index) {
        if (arr == null || arr.length == 0) {
            System.out.println("数组为空，不能遍历");
        }
        //输出当前这个元素
        System.out.println(arr[index]);
        //向左递归遍历
        if (index * 2 + 1 < arr.length) {
            preOrder(index * 2 + 1);
        }
        //向右递归遍历
        if (index * 2 + 2 < arr.length) {
            preOrder(index * 2 + 2);
        }
    }

    //中序存储二叉树
    public void infixOrder(int index) {
        if (arr == null && arr.length == 0) {
            System.out.println("数组为空，不能遍历");
        }
        //向左递归遍历
        if (index * 2 + 1 < arr.length) {
            infixOrder(index * 2 + 1);
        }
        //输出当前结点
        System.out.println(arr[index]);
        //向右递归遍历
        if (index * 2 + 2 < arr.length) {
            infixOrder(index * 2 + 2);
        }
    }

    //后序存储二叉树
    public void postOrder(int index) {
        if (arr == null || arr.length == 0) {
            System.out.println("链表为空，无法存储");
        }
        //向左递归遍历
        if (index * 2 + 1 < arr.length) {
            postOrder(index * 2 + 1);
        }
        //向右递归
        if (index * 2 + 2 < arr.length) {
            postOrder(index * 2 + 2);
        }
        //输出当前的结点
        System.out.println(arr[index]);
    }
}
```



**线索化二叉树**

先看一个问题：将数列{1,3,6,8,10,14}构建成一颗二叉树

![image-20210609110307267](/Users/mac/Library/Application Support/typora-user-images/image-20210609110307267.png)



问题分析：

1. 当我们对上面的二叉树进行中序遍历时，数列为{8,3,10,1,14,6}
2. 但是6,8,10,14这几个结点的左右指针，并没有完全的利用上
3. 如果我们希望充分的利用各个结点的左右指针，让各个结点可以指向自己的前后结点，该怎么办？
4. 解决方案：线索二叉树

**线索二叉树基本介绍**

1. n个结点的二叉链表中含有n+1个空指针域，利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为“线索”）
2. 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树（Threaded BinaryTree）。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树
3. 一个结点的前一个结点，称为**前驱**结点
4. 一个结点的后一个结点，称为**后继**结点

![image-20210609141936228](/Users/mac/Library/Application Support/typora-user-images/image-20210609141936228.png)

说明：当线索化二叉树后，Node结点属性left和right，有如下情况：

1. left指向的是左子树，也可能指向的前驱结点。比如：1结点left指向的左子树，而10结点的left指向的是前驱结点

2. right指向的是右子树，也可能是指向后继结点。比如：1结点right指向的是右子树，而10结点right指向的是后继结点。

3. ```java
   //说明：
   //如果leftType == 0 表示指向的是左子树，如果==1表示指向前驱结点
   //如果rightType == 0 表示指向的是右子树，如果==1表示指向后继结点
   ```

**代码实现**

```java
//编写对二叉树进行中序线索化的方法
public void threadedNodes(HeroNode node) {
    //如果node==null，不能线索化
    if (node == null) {
        return;
    }
    //一、先线索化左子树
    threadedNodes(node.getLeft());
    //二、再处理当前结点的前驱结点
    if (node.getLeft() == null) {
        node.setLeft(pre);
        node.setLeftType(1);//指向的是前驱结点
    }

    //处理当前结点的后继结点（这一步是在进行下一个结点操作的时候才做的）
    if (pre != null && pre.getRight() == null) {
        //让前驱结点的右指针指向当前结点
        pre.setRight(node);
        //修改当前结点的右指针类型
        pre.setRightTyp(1);
    }
    //最关键的一步：每处理一个结点后，让当前结点是下一个结点的前驱结点
    pre = node;
    //三、线索化右子结点
    threadedNodes(node.getRight());
}
```



**遍历线索二叉树**

说明：对前面的中序线索化的二叉树，进行遍历

分析：因为线索化后，各个结点指向有变化，因此原来的遍历方式哦不能使用，这时需要使用新的方式遍历线索二叉树，各个结点可以通过线性方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。遍历的次序应当和中序遍历保持一致。

**代码实现**

```java
//遍历线索化二叉树的方法
public void threadedList() {
    //定义一个变量存储当前遍历的结点
    HeroNode node = root;

    while (node != null) {
        //循环判断找到leftType == 1的结点，第一个就是8
        //后面随着遍历而变化，因为leftType == 1时，说明该结点是按照锡奥所花
        //处理之后的结点
        while (node.getLeftType() == 0) {//这里就在一直找
            node = node.getLeft();
        }
        //找到过后输出
        System.out.println(node);
        //如果当前结点的右指针是后继结点，就一直输出
        while (node.getRightTyp() == 1){
            node = node.getRight();
            System.out.println(node);
        }
        //替换这个遍历的结点
        node = node.getRight();
    }

```





### 二叉树的应用





#### 堆排序

1. 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn),它也是不稳定排序
2. 堆是具有以下性质的完全二叉树，每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆，注意：没有要求结点的左孩子的值和右孩子的值的大小关系。
3. 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。
4. 大顶堆举例说明：

![image-20210610094155456](file:///Users/mac/Library/Application%20Support/typora-user-images/image-20210610094155456.png?lastModify=1622730264)



小顶堆举例说明

![image-20210610094505196](file:///Users/mac/Library/Application%20Support/typora-user-images/image-20210610094505196.png?lastModify=1622730264)



**堆排序的基本思想**

1. 将待排序的序列构造成一个大顶堆。
2. 此时，整个序列的最大值就是堆顶的根结点。
3. 将其与末尾元素进行交换，此时末尾就为最大值
4. 然后将剩余n-1个元素重新构造成一个堆，这样就会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。



可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了。

原始的数组是【4，6，8，5，9】

![image-20210610103744576](file:///Users/mac/Library/Application%20Support/typora-user-images/image-20210610103744576.png?lastModify=1622730264)





![image-20210610103842374](file:///Users/mac/Library/Application%20Support/typora-user-images/image-20210610103842374.png?lastModify=1622730264)



![image-20210610103957703](file:///Users/mac/Library/Application%20Support/typora-user-images/image-20210610103957703.png?lastModify=1622730264)

![image-20210610104129396](file:///Users/mac/Library/Application%20Support/typora-user-images/image-20210610104129396.png?lastModify=1622730264)

此时，我们就将一个无序序列构造成了一个大顶堆。

**思路分析**

1. 将无序序列构成一个堆，根据升序降序需求选择大顶堆或者小顶堆；
2. 将堆顶元素与末尾元素交换，将最大元素”沉“到数组末端
3. 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序



**代码实现**

```
//将一个数组（二叉树），调整成一个大顶堆/
/**
 * 功能：完成以i对应的非叶子结点的树调整成大顶堆
 * 举例：int arr[] = {4,6,8,5,9}; => i = 1 =>adjustHeap =>得到{4,9,8,5,6}
 * 如果再次调用 adjustHeap 传入的是 i = 0 => 得到{4,9,8,5,6} => {9,6,8,5,4}
 *
 * @param arr    待调整的数组
 * @param i      表示非叶子结点在数组中的索引
 * @param length 表示对多少个元素继续调整，length是在逐渐的减少
 */
public static void adjustHeap(int arr[], int i, int length) {
    int temp = arr[i];//先把i这个结点的数存到临时变量中

    //从第i个元素的左子结点开始找起,找到子结点中最大的
    for (int k = 2 * i + 1; k < length; k = k * 2 + 1) {
        if (k + 1 < length && arr[k] < arr[k + 1]) {//说明左子结点的值小于右子结点
            k++;//k指向右子结点
        }
        if (arr[k] > temp) {//如果子结点的最大值大于父结点
            arr[i] = arr[k];//交换
            i = k;
        } else {
            break;
        }
    }
    //for循环后，我们已经将以i为父结点最大值，放在了最新（局部）
    arr[i] = temp;//将temp放到调整过后的位置
}
```



```
public static void main(String[] args) {
    int temp = 0;
    int[] arr = {4, 6, 8, 5, 9};
    int count = 1;
    for (int i = arr.length / 2 - 1; i >= 0; i--) {
        adjustHeap(arr, i, arr.length);
        System.out.println("第"+count+"次调整后的结果：" + Arrays.toString(arr));
        count++;
    }


    /**
     * 将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端
     * 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序
     */
    for (int j = arr.length - 1; j > 0; j--) {
        temp = arr[j];
        arr[j] = arr[0];
        arr[0] = temp;
        adjustHeap(arr,0,j);
    }
            System.out.println("数组等于：" + Arrays.toString(arr));
```



#### 赫夫曼树

**基本介绍**：

1. 给定n个权值作为n个叶子结点，构造一颗二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)，还有的书翻译为赫夫曼树
2. 赫夫曼树是带权路径长度最短的树，权值较大的结点离根结点较近

**重要概念和距离说明**

1. 路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径，通路中分支的数目称为路径长度，若规定根结点的层数是1，则从根结点到第L层结点的路径长度是L-1。
2. **结点的权及带权路径长度**：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。
3. 树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为：WPL(weight path length),权值越大的结点离根结点越近的而二叉树才是最优二叉树
4. WPL最小的就是赫夫曼书

![image-20210611094756255](file:///Users/mac/Library/Application%20Support/typora-user-images/image-20210611094756255.png?lastModify=1622730264)



赫夫曼树创建思路：

给定一个数列：{13,7,8,3,29,6,1}要求转成一个赫夫曼树

1. 从小到大进行排序，将每一个数据，每个数据都是一个结点，每个结点可以看成是一颗最简单的二叉树
2. 取出根结点权值最小的两颗二叉树
3. 组成一颗新的二叉树，该新的二叉树的根结点的权值前面两颗二叉树根结点权值之和
4. 再将这颗新的二叉树，以根结点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树。

**代码实现**

```
 /**
     * @param arr 需要创建成赫夫曼树的数组
     * @return  创建好的赫夫曼树的root结点
     */
    //创建赫夫曼树的方法
    public static Node createHuffmanTree(int[] arr) {
        //第一步为了方便操作
        //1、遍历arr数组
        //2、将arr的每个元素构成一个Node
        //3、将Node放入到ArrayList当中
        ArrayList<Node> nodes = new ArrayList<>();
        for (int value : arr) {
            nodes.add(new Node(value));
        }
        while (nodes.size() > 1) {
            //从小到大排序
            Collections.sort(nodes);
//            System.out.println("nodes = " + nodes);
            //取出根节点最小的两颗二叉树
            //1、取出权值最小的节点（二叉树）
            Node leftNode = nodes.get(0);
            //2、取出权值第二小的节点（二叉树）
            Node rightNode = nodes.get(1);
            //3、构建一颗新的二叉树
            Node parent = new Node(leftNode.value + rightNode.value);
            parent.left = leftNode;
            parent.right = rightNode;
            //4、从ArrayList删除处理过的二叉树
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            //5、将新的二叉树的结点加入到链表
            nodes.add(parent);
        }
       return nodes.get(0);
    }
}
```



#### 赫夫曼编码

**基本介绍**

1. 赫夫曼编码也翻译为 哈夫曼编码，又称霍夫曼编码，是一种编码方式，属于一种程序算法
2. 赫夫曼编码是赫夫曼树在电讯通信中的经典应用之一
3. 赫夫曼编码广泛的应用于数据文件压缩。其压缩率通常在20%-90%之间
4. 赫夫曼码是可变字长编码(VLC)的一种，Huffman与1952年提出的一种编码方式，称为最佳编码
5. ![image-20210611142014201](/Users/mac/Library/Application Support/typora-user-images/image-20210611142014201.png)



**编码过程介绍**

![image-20210611143605901](/Users/mac/Library/Application Support/typora-user-images/image-20210611143605901.png)

![image-20210611143648558](/Users/mac/Library/Application Support/typora-user-images/image-20210611143648558.png)

![image-20210611143711557](/Users/mac/Library/Application Support/typora-user-images/image-20210611143711557.png)

![image-20210611143729625](/Users/mac/Library/Application Support/typora-user-images/image-20210611143729625.png)

发送的时候还是以8bit一字节的形式发

赫夫曼压缩是无损压缩



**注意**：这个赫夫曼树根据排序方法的不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，**但是wpl是一样的**，都是最小的，比如：如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个。







功能：根据赫夫曼编码压缩数据的原理，需要创建”I like like like  java do you like java“对应的赫夫曼树

思路：

1. 构建一个新的结点 Node {data{存放数据};  weigh(权值)，left  right}
2. 得到 ”I like like like  java do you like java“对应的byte[]数组
3. 编写一个方法，将准备构建赫夫曼树的Node结点放到List,形式[Node{data=97,weight = 57},Node{data = 32,weight = 9},....]
4. 可以通过List创建对应的赫夫曼树



**代码实现**

```java
/**
 * 接收一个字节数组
 * @param bytes 接收字节数组
 * @return 返回的是一个List形式
 */
//获取节点
public static List<Node> getNodes(byte[] bytes) {
    //1、创建一个ArrayLists
    ArrayList<Node> nodes = new ArrayList<>();

    //2、遍历bytes数组,统计每一个人byte出现的次数
    HashMap<Byte, Integer> counts = new HashMap<>();
    for (byte b : bytes) {
        Integer count = counts.get(b);
        if (count == null) {//说明是第一次遍历
            //把这个数记作1
            counts.put(b, 1);
        } else {//这个数不是第一次出现
            counts.put(b, count + 1);//遇到一个byte就加一个
        }
    }
    //把每一个键值对转换成一个Node对象
    for (Map.Entry<Byte, Integer> entry : counts.entrySet()) {
        nodes.add(new Node(entry.getKey(), entry.getValue()));
    }

    return nodes;

}
```



```java
/**
 * 功能：将传入的Node结点的所有叶子结点的赫夫曼编码得到，并存放到huffmanCode集合中
 *
 * @param node          传入的结点
 * @param code          代表路径：左子节点是 0  右子节点是 1
 * @param stringBuilder 是用来拼接路径的
 */
private static void getCode(Node node, String code, StringBuilder stringBuilder) {
    StringBuilder stringBuilder2 = new StringBuilder(stringBuilder);
    stringBuilder2.append(code);
    if (node != null) {//如果node == null不处理
        //判断当前的结点是叶子结点还是非叶子结点
        if (node.data == null){//非叶子结点
            //递归处理
            //向左递归
            getCode(node.left,"0",stringBuilder2);
            //向右递归
            getCode(node.right,"1",stringBuilder2);
        }else {
            //说明是一个叶子结点
            //说明找到某个叶子结点的最后
            huffmanCodes.put(node.data,stringBuilder2.toString());
        }

    }
}
```



```java
/**
 * @param bytes        原始的字符串对应的byte数组
 * @param huffmanCodes 生成的赫夫曼编码
 * @return 返回赫夫曼编码处理后的一个byte数组
 * 举例：String content = "I like like like java do you like a java"; => byte[] contentBytes = content.getBytes();
 * 返回的字符串是"1010100010111111......."所对应的byte[] huffmanCodeByte,即8位对应一个byte
 * 放入到huffmanCodeByte[] 中
 * huffmanBodeBytes[0] = 10101000(补码) => byte [推导：10101000 => 10101000 - 1 => 10100111(反码)
 * => 11011000 -- >-88]
 */
private static byte[] zip(byte[] bytes, Map<Byte, String> huffmanCodes) {
    StringBuilder stringBuilder = new StringBuilder();
    //1、利用huffmanCode 将不有特殊 转成 赫夫曼编码对应的地字符串
    for (byte b : bytes) {
        String str = huffmanCodes.get(b);
        stringBuilder.append(str);
    }
    //System.out.println("赫夫曼编码压缩后的二进制字符串" + stringBuilder.toString());
    //确定编码后的长度
    int len;
    if (stringBuilder.length() % 8 == 0) {
        len = stringBuilder.length() / 8;
    } else {
        len = stringBuilder.length() / 8 + 1;
    }
    //创建数据压缩后的byte数组
    byte[] huffmanCodeBytes = new byte[len];
    int index = 0;//记录是第几个byte
    for (int i = 0; i < stringBuilder.length(); i += 8) {
        String strByte;
        if (i + 8 > stringBuilder.length()) {//不够8位
            strByte = stringBuilder.substring(i);
        } else {
            strByte = stringBuilder.substring(i, i + 8);
        }
        //将strByte转成一个byte放到huffmanCoeBytes里
        huffmanCodeBytes[index] = (byte) Integer.parseInt(strByte, 2);
        index++;
    }
    return huffmanCodeBytes;
}
```



```java
//编写一个方法对压缩数据的解码
/**
 * @param huffmanCodes 赫夫曼编码表
 * @param huffmanBytes 赫夫曼编码得到的字节数组
 * @return 返回的是
 */
private static byte[] deCode(Map<Byte, String> huffmanCodes, byte[] huffmanBytes) {
    //先得道HuffmanBytes 对应的二进制的字符串，形式：1010100010111
    StringBuilder stringBuilder = new StringBuilder();
    //将byte数组转成二进制的字符串
    for (int i = 0; i < huffmanBytes.length; i++) {
        byte b = huffmanBytes[i];
        //判断是不是最后一个字节。因为最后一个自己不需要补高位
        boolean flag = (i == huffmanBytes.length - 1);
        stringBuilder.append(byteToBitString(!flag, b));
    }
    System.out.println("赫夫曼编码字节数组对应的二进制字符串" + stringBuilder);

    //把字符串按照指定的赫夫曼编码进行解码
    //吧把赫夫曼编码表进行调换，因为反向查询 a->100  100->a
    HashMap<String, Byte> map = new HashMap<>();
    for (Map.Entry<Byte, String> entry : huffmanCodes.entrySet()) {
        map.put(entry.getValue(), entry.getKey());
    }
    //创建一个集合，存放byte
    ArrayList<Byte> list = new ArrayList<>();

    //I可以理解成是索引，扫描stringBuilder
    for (int i = 0; i < stringBuilder.length();) {
        int count = 1;//相当于是一个干活的，一直往后跑
        boolean flag = true;
        Byte b = null;
        while (flag) {
            //扫描stringBuilder
            String key = stringBuilder.substring(i, i + count);
            b = map.get(key);//看看扫描到的这个二进制在反编码表中有没有
            if (b == null) {//如果没有这个编码，让count继续往后扫描
                count++;
            } else {//如果找到一个直接退出
                flag = false;
            }
        }
        //while循环退出的时候，说明找到一个
        list.add(b);
        i += count;//subString不包含尾
    }
    //for循环结束以后，list就存放了所有的字符
    //把list中的数据放入到byte[]并返回
    byte b[] = new byte[list.size()];
    for (int i = 0; i < list.size(); i++) {
        b[i] = list.get(i);
    }
    return b;
}


//编写一个方法，将字符串对应的byte[]数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码 压缩后的byte[]

/**
 * 将一个byte转成二进制的字符串
 *
 * @param flag 标示是否需要补高位，如果是true，就标示要补高位，如果是false表示不补，如果是最后一个字节无需补高位
 * @param b    传入的byte
 * @return 是该b对应的二进制的字符串（按补码返回的）
 */
private static String byteToBitString(boolean flag, byte b) {
    //使用变量保存b
    int temp = b;//将b转成int
    //如果是正数还存在补高位
    if (flag) {
        temp |= 256;//按位与256    1 0000 0000 | 0000 0000 => 1 0000 0001
    }
    String str = Integer.toBinaryString(temp);//返回的是temp对应的二进制的补码
    if (flag) {
        return str.substring(str.length() - 8);
    } else {
        return str;
    }


}
```



#### 赫夫曼编码的最佳实践 - 文件压缩



对文件的压缩和解压，具体要求：给定一个图片文件，要求对其进行无损压缩，看看压缩效果如何。

思路：读取文件->得到赫夫曼编码->完成压缩

```java
//编写一个方法：将一个文件压缩
public static void zipFile(String srcFile,String dstFile) {
    //创建输出流
    OutputStream os = null;
    ObjectOutputStream oos = null;
    //创建文件输入流
    FileInputStream is = null;
    try {
        //创建文件的输入流
        is = new FileInputStream(srcFile);
        //创建一个和源文件一样大小的数组
        byte[] b = new byte[is.available()];
        //读取文件
        is.read(b);
        //直接对源文件压缩
        byte[] huffmanBytes = huffmanZip(b);
        //创建文件的输出流，存放压缩文件
        os = new FileOutputStream(dstFile);
        //创建一个和文件输出流关联的ObjectOutputStream
        oos = new ObjectOutputStream(os);
        //把赫夫曼编码后的字节数组写入压缩文件
        oos.writeObject(huffmanBytes);
        //这里以对象流的方式写入赫夫曼编码，是为了以后恢复源数据
        //注意一定要把赫夫曼编码写入压缩文件
        oos.writeObject(huffmanCodes);
    }catch (Exception e){
        System.out.println(e.getMessage());
    }finally {
        try {
            is.close();
            os.close();
            oos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```



```java
//测试压缩文件的代码
String srcFile = "/Users/mac/Desktop/吉他谱/src.jpg";
String dstFile = "/Users/mac/Desktop/吉他谱/des.zip";
zipFile(srcFile,dstFile);
System.out.println("压缩文件成功");
```





#### 赫夫曼编码最佳实践-文件压缩



具体要求：将前面的压缩文件，重新恢复成原来的文件

思路：读取压缩文件（数据和赫夫曼编码表）->完成解压

```java
//完成解压文件的方法

/**
 * @param zipFile 需要解压的文件
 * @param dstFile 解压到的路径
 */
public static void unZip(String zipFile,String dstFile){
    //定义文件的输入流
    InputStream is = null;
    //定义一个对象输入流
    ObjectInputStream ois = null;
    //定义文件的输出流
    OutputStream os = null;
    try{
        //创建文件输入流
       is =  new FileInputStream(zipFile);
       //创建一个和 is相关联的对象输入流
        ois = new ObjectInputStream(is);
        //读取byte[]数组和huffmanBytes
        byte[] huffmanBytes = (byte[])ois.readObject();
        //读取赫夫曼编码表
        Map<Byte,String> huffmanCodes = (Map<Byte,String>)ois.readObject();

        //解码
        byte[] bytes = deCode(huffmanCodes, huffmanBytes);
        //将bytes写入到目标文件
        os = new FileOutputStream(dstFile);
        //写数据到file文件
        os.write(bytes);

    }catch (Exception e){
        System.out.println(e.getMessage());
    }finally {
        try {
            ois.close();
            os.close();
            is.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
```



```java
//测试解压文件
String zipFile = "/Users/mac/Desktop/吉他谱/des.zip";
String dstFile = "/Users/mac/Desktop/吉他谱/src2.jpg";
unZip(zipFile,dstFile);
System.out.println("解压成功！");
```



#### 赫夫曼编码压缩文件注意事项



1. 如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化。
2. 赫夫曼编码是按字节来处理的，因此可以处理所有的文件
3. 如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显。





#### 二叉排序树



二叉排序树上（BTS）:对于二叉排序树的任何一个非叶子节点，要求左子节点比当前节点的值小，右子节点的值比当前节点的值大。



```java
class BinaryTree {
    private Node root;
    //添加节点
    public void add(Node node) {
        if (root == null) {
            root = node;
        } else {
            root.add(node);
        }
    }

    //中序遍历
    public void infixOrder() {
        if (root != null) {
            root.infixOrder();
        } else {
            System.out.println("当前二叉树为空");
        }
    }
}

class Node {
    int value;
    Node left;
    Node right;

    public Node(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    //添加节点的方法
    //递归形式添加节点，注意需要满足二叉排序树的要求
    public void add(Node node) {
        if (node == null) {
            return;
        }
        //判断传入节点的值和当前节点的关系
        if (node.value < this.value) {
            if (this.left == null) { //如果当前节点左子节点是空的直接挂上去
                this.left = node;
            } else {
                //递归向左子树添加
                this.left.add(node);
            }
        } else {
            if (this.right == null) {
                this.right = node;
            } else {
                //递归向右子树添加
                this.right.add(node);
            }
        }
    }

    //中序遍历
    public void infixOrder() {
        if (this.left != null) {
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right != null) {
            this.right.infixOrder();
        }
    }
}
```



**二叉排序树的删除（三种情况）**

![image-20210814174850503](/Users/mac/Library/Application Support/typora-user-images/image-20210814174850503.png)

1. 删除叶子节点（比如，2，5，9，12）

   思路：

   1. 找到要删除的节点 targetNode

   2. 找到targetNode的父节点，parent

   3. 确定targetNode是parent的左子节点还是右子节点

   4. 根据前面的情况对应删除

      左子节点：parent.left = null

      右子节点：parent.right = null

2. 删除只有一颗子树的节点，比如1

   1. 找到要删除的节点 targetNode

   2. 找到targetNode的父节点，parent

   3. 确定targetNode的子节点是左子节点还是右子节点

   4. 确定targetNode是parent的左子节点还是右子节点

   5. 如果targetNode有左子节点

      5..1  如果targetNode是parent的左子节点

      parent.left = targetNode.left

      5.2  如果targetNode是parent的右子节点

      parent.right = targetNode.left

   6. 如果targetNode有右子节点

      6.1  如果targetNode是parent的左子节点

      parent.left = targetNode.right

      6.2  如果targetNode是parent的右子节点

      parent.right = targetNode.right

3. 删除有两颗子树的节点（比如，7，3，10）

   1. 找到要删除的节点 targetNode
   2. 找到targetNode的父节点，parent
   3. 从targetNode的右子树找到最小的结点
   4. 用一个临时变量，将最小结点的值保存 temp = 12
   5. 删除该最小结点
   6. targetNode.value = temp



```java
    //查找要删除的结点
    public Node search(int value) {
        if (root == null) {
            return null;
        } else {
            return root.search(value);
        }
    }

    //查找父节点
    public Node searchParent(int value) {
        if (root == null) {
            return null;
        } else {
            return root.searchParent(value);
        }
    }

    //删除结点
    public void delNode(int value) {
        if (root == null) {
            return;
        } else {
            //找到要删除的结点
            Node targetNode = search(value);
            if (targetNode == null) {
                return;
            }
            //如果我们发现这课二叉排序树只有一个结点
            if (root.left == null && root.right == null) {
                root = null;
                return;
            }
            //找到targetNode的父节点
            Node parent = searchParent(value);
            //如果要删除的结点是叶子结点
            if (targetNode.left == null && targetNode.right == null) {
                //判断targetNode 是父节点的左子节点还是右子节点
                if (parent.left != null && parent.left.value == targetNode.value) {
                    //是左子节点
                    parent.left = null;
                } else if (parent.right != null && parent.right.value == targetNode.value) {
                    parent.right = null;
                }
            } else if (targetNode.left != null && targetNode.right != null) {
                //删除的是有两颗子树的结点
                int minValue = delRightTreeMin(targetNode.right);
                targetNode.value = minValue;

            } else {//删除只有一颗子树的结点
                //如果要删除的结点有左子节点
                if (targetNode.left != null) {
                    if (parent != null) {
                        if (parent.left.value == value) {
                            //如果targetNode是parent的左子节点
                            parent.left = targetNode.left;
                        } else {//如果要删除的结点有右子节点
                            parent.right = targetNode.left;
                        }
                    } else {
                        root = targetNode.left;
                    }
                } else {
                    if(parent !=null){
                        //如果要删除的结点有右子节点
                        if (parent.left.value == value) {
                            //如果targetNode是parent的左子节点
                            parent.left = targetNode.right;
                        } else {//如果targetNode是parent的右子节点
                            parent.right = targetNode.right;
                        }
                    }else {
                        root = targetNode.right;
                    }
                }

            }

        }
    }
```

```java
/**
 * @param node 传入的结点（当做二叉排序树的根节点）
 * @return 返回的 以node为根节点的二叉排序树的最小结点的值
 */
public int delRightTreeMin(Node node) {
    Node target = node;
    //虚幻的查找左子节点，就会找到最小值
    while (target.left != null) {
        target = target.left;
    }
    //此时target指向了最小值
    //删除最小结点
    delNode(target.value);
    return target.value;
}
```



#### 平衡二叉树（AVL树）

1. 也叫平衡二叉搜索树，可以保证查询效率较高
2. 具有以下特点：它是一颗空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一颗平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等

**当右子树高度大于左子树高度的时候，进行左旋转**

1. 创建一个新的节点newNode，值等于当前根节点的值
2. 把新节点的左子树设置为当前节点的左子树
3. 把新节点的右子树设置为当前节点的**右子树的左子树**
4. 把当前节点的值（根）换位右子节点的值
5. 把当前节点的右子树设置为右子树的右子树
6. 把当前节点的左子树设置为新节点（newNode）

![image-20210814202602112](/Users/mac/Library/Application Support/typora-user-images/image-20210814202602112.png)

![image-20210814202612107](/Users/mac/Library/Application Support/typora-user-images/image-20210814202612107.png)



```java
//左旋转的方法
private void leftRotate() {
    //创建新的结点，以当前根节点的值
    Node newNode = new Node(this.value);
    //把新结点的左子树设置为当前结点的左子树
    newNode.left = this.left;
    //把新结点的右子树设置成当前结点的右子树的左子树
    newNode.right = this.right.left;
    //把当前结点的值换成右子节点的值
    this.value = this.right.value;
    //把当前结点的右子树设置成当前结点的右子树的右子树
    this.right = right.right;
    //把当前结点的左子树（左子节点）设置成新的结点
    this.left = newNode;
}
```





**左子树的高度高于右子树的高度，右旋转**

1. 创建一个新的结点newNode，值等于当前节点的值
2. 把新结点的右子树设置为当前节点的右子树
3. 把新结点的左子树设置为当前节点的左子树的右子树
4. 把当前结点的值换位左子节点的值
5. 当前节点的左子树设置成左子树的左子树
6. 把当前节点的右结点设置为新结点



![image-20210814204335911](/Users/mac/Library/Application Support/typora-user-images/image-20210814204335911.png)

![image-20210814204348158](/Users/mac/Library/Application Support/typora-user-images/image-20210814204348158.png)



```java
//右旋转
private void rightRotate() {
    Node newNode = new Node(this.value);
    newNode.right = this.right;
    newNode.left = this.left.right;
    this.value = this.left.value;
    this.left = left.left;
    this.right = newNode;
}
```





**双旋转问题**

![image-20210814204931180](/Users/mac/Library/Application Support/typora-user-images/image-20210814204931180.png)

问题分析：

1. 当符合右旋转的时候
2. 如果它的左子树的右子树高度大于它的左子树的高度（2>1）
3. 先对当前结点的左子节点进行左旋转
4. 再对当前节点进行右旋转操作即可





**二叉树的问题**

二叉树需要加载到内存，如果二叉树的结点很多，构建的时候需要多次进行I/O操作，如果结点海量，会造成二叉树的高度很大，会降低操作速度。

解决方法：

**多叉树**

1. 允许每个结点可以有更多的子结点

![image-20210815095326744](/Users/mac/Library/Application Support/typora-user-images/image-20210815095326744.png)

**B树**

![image-20210815095442727](/Users/mac/Library/Application Support/typora-user-images/image-20210815095442727.png)

1. B树通过重新组织结点，降低了高度
2. 2-3树是最简单的B树，具有以下特点：
   1. 所有的叶子结点都在同一层
   2. 有两个结点的叫二结点，二结点要么没有子结点，有么有两个子结点
   3. 有三个结点的叫三结点，三结点要么没有结点，有么有三个结点
   4. 2-3树是由二结点和三结点构成的树













### 图

图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间连接的称为边。结点也可以称为顶点。如图：

![image-20210815161914983](/Users/mac/Library/Application Support/typora-user-images/image-20210815161914983.png)



**常用概念**

1. 顶点（vertex）
2. 边（edge）
3. 路径
4. 无向图
5. 有向图
6. 带权图



**图的表示方式**

1. 二维数组（邻接矩阵）

   邻接矩阵是表示图形中顶点之间相邻关系的矩阵

   ![image-20210815162450091](/Users/mac/Library/Application Support/typora-user-images/image-20210815162450091.png)

   

2. 链表表示（邻接表）

   邻接矩阵需要为每个顶点都分配n个边的空间，其实有很边都是不存在的，会造成空间的一定损失。

   邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间的浪费，邻接表由数组+链表组成

   ![image-20210815162740670](/Users/mac/Library/Application Support/typora-user-images/image-20210815162740670.png)



**快速入门**

![image-20210815162954465](/Users/mac/Library/Application Support/typora-user-images/image-20210815162954465.png)



**图的创建**

```java
public class Graph {

    private ArrayList<String> vertexList; //存储顶点集合
    private int[][] edges;//存储图对应的邻接矩阵
    private int numOfEdges;//表示边的数目

    //构造器
    public Graph(int n) {
        //初始化矩阵和vertex
        edges = new int[n][n];
        vertexList = new ArrayList<String>(n);
        numOfEdges = 0;
    }

    //图中常用的方法
    //返回结点的个数
    public int getNumOfVertex() {
        return vertexList.size();
    }

    //显示图对应的矩阵
    public void showGraph(){
        for (int[] link : edges){
            System.out.println(Arrays.toString(link));
        }
    }

    //得到边的个数
    public int getNumOfEdges() {
        return numOfEdges;
    }

    //返回结点i（下标）对应的数据 0 -> "A"  1->"B"  2->"C"
    public String getValueByIndex(int i) {
        return vertexList.get(i);
    }

    //返回v1 和 v2的权值
    public int getWeight(int v1, int v2) {
        return edges[v1][v2];
    }

    //插入结点
    public void insertVertex(String vertex) {
        vertexList.add(vertex);
    }

    //添加边
    /**
     * @param v1     表示点的下标即第几个顶点  "A"-"B"  "A"->0  "B"->1
     * @param v2     第二个顶点对应的下标
     * @param weight 表示权值
     */
    public void insertEdges(int v1, int v2, int weight) {
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    }
}

 public static void main(String[] args) {
        //测试图创建是否oK

        int n = 5;
        String Vertexs[] = {"A","B","C","D","E"};
        //创建图对象
        Graph graph = new Graph(n);
        //循环添加顶点
        for (String vertex: Vertexs){
            graph.insertVertex(vertex);
        }
        //添加边
        //A-B A-C B-C B-D B-E
        graph.insertEdges(0,1,1);
        graph.insertEdges(0,2,1);
        graph.insertEdges(1,2,1);
        graph.insertEdges(1,3,1);
        graph.insertEdges(1,4,1);

        //显示邻接矩阵
        graph.showGraph();
    }
```



#### 图的深度优先遍历（DFS）

所谓图的遍历，就是对结点的访问。一个图有那么多的结点，如果遍历这些结点，需要特定的策略，一般有两种访问策略：

1. 深度优先遍历（DFS）
2. 广度优先遍历

**图的深度优先遍历**

1. 深度优先遍历，从初试访问结点出发，初试访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初试结点，访问它的第一个邻接结点，可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。
2. 可以看到，这样的访问策略是优先往纵向挖掘深入，而不是一个结点的所有节点进行横向访问。
3. 显然，深度优先搜索是一个递归的过程。



**图的深度优先遍历-王卓版讲解**

1. 在访问图中某一起始顶点v后，由v出发，访问它的任一邻接顶点w1；
2. 再从w1出发，访问与w1邻接但还未被访问过的顶点w2;
3. 然后再从w2出发，进行类似访问，。。。
4. 如此进行下去，直到到达所有的邻接顶点都被访问过的顶点u为止。
5. 接着，回退一步，退到前一次刚访问过的顶点，看是否还有其他没有被访问过的顶点。
6. 如果有：则访问此顶点，之后再从此顶点出发，进行与前述类似的访问；
7. 如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止

**深度优先遍历算法步骤**

1. 访问初始结点v，并标记结点v为已访问
2. 查找结点v的第一个邻接结点w
3. 若w存在，则继续执行4，如果w不存在，则回到第一步，将从v的下一个结点继续
4. 若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行1，2，3）
5. 查找结点v的w邻接结点的下一个邻接结点，转到步骤3





举例：

![image-20210815171018412](/Users/mac/Library/Application Support/typora-user-images/image-20210815171018412.png)



图的特点：

​	图中可能存在回路，且图的任一顶点都可能与其他顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点



**怎样避免重复访问**

解决思路：设置辅助数组visited[n],用来标记每个被访问过的顶点。

初试状态visited[i]为0

顶点i被访问，改visited[i]为1，防止多次被访问



```java
public class Graph {

    private ArrayList<String> vertexList; //存储顶点集合
    private int[][] edges;//存储图对应的邻接矩阵
    private int numOfEdges;//表示边的数目

    //定义给定数组boolean[],记录某个结点是否被访问
    private boolean[] isVisited;

    //得到第一个邻接结点的下标w
    public int getFirstNeighbor(int index) {
        for (int j = 0; j < vertexList.size(); j++) {
            if (edges[index][j] > 1) {
                return j;
            }
        }
        return -1;
    }

    //根据前一个邻接结点的下标来获取下一个邻接结点
    //v1 是前一个邻接结点， v2是当前结点
    public int getNextNeighbor(int v1,int v2) {
        for (int j = v2 +1;j < vertexList.size();j++){
            if (edges[v1][j] > 0){
                return j;
            }
        }
        return -1;
    }

    //深度优先遍历
    //i 第一次就是0
    public void dfs(boolean[] isVisited,int i){
        //首先访问该结点
        System.out.print(getValueByIndex(i) + "->");
        //将结点设置为已经访问过
        isVisited[i] = true;

        //查找结点i的第一个邻接结点w
        int w = getFirstNeighbor(i);
        while (w != -1){//说明有邻接结点
            if (!isVisited[w]){//如果没有被访问过
                dfs(isVisited,w);
            }
            //如果w结点已经被访问过
            w = getNextNeighbor(i,w);
        }
    }

    //对dfs进行重载，遍历所有的结点，进行dfs
    public void dfs(){
        //遍历所有的结点进行dfs
        for (int i =0;i < getNumOfVertex();i++){
            if (!isVisited[i]){
                dfs(isVisited,i);
            }
        }
    }

    //构造器
    public Graph(int n) {
        //初始化矩阵和vertex
        edges = new int[n][n];
        vertexList = new ArrayList<String>(n);
        numOfEdges = 0;
        isVisited = new boolean[n];
    }

    //图中常用的方法
    //返回结点的个数
    public int getNumOfVertex() {
        return vertexList.size();
    }

    //显示图对应的矩阵
    public void showGraph() {
        for (int[] link : edges) {
            System.out.println(Arrays.toString(link));
        }
    }

    //得到边的个数
    public int getNumOfEdges() {
        return numOfEdges;
    }

    //返回结点i（下标）对应的数据 0 -> "A"  1->"B"  2->"C"
    public String getValueByIndex(int i) {
        return vertexList.get(i);
    }

    //返回v1 和 v2的权值
    public int getWeight(int v1, int v2) {
        return edges[v1][v2];
    }

    //插入结点
    public void insertVertex(String vertex) {
        vertexList.add(vertex);
    }

    //添加边

    /**
     * @param v1     表示点的下标即第几个顶点  "A"-"B"  "A"->0  "B"->1
     * @param v2     第二个顶点对应的下标
     * @param weight 表示权值
     */
    public void insertEdges(int v1, int v2, int weight) {
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    }


    public static void main(String[] args) {
        //测试图创建是否oK

        int n = 5;
        String Vertexs[] = {"A", "B", "C", "D", "E"};
        //创建图对象
        Graph graph = new Graph(n);
        //循环添加顶点
        for (String vertex : Vertexs) {
            graph.insertVertex(vertex);
        }
        //添加边
        //A-B A-C B-C B-D B-E
        graph.insertEdges(0, 1, 1);
        graph.insertEdges(0, 2, 1);
        graph.insertEdges(1, 2, 1);
        graph.insertEdges(1, 3, 1);
        graph.insertEdges(1, 4, 1);

        //显示邻接矩阵
        graph.showGraph();

        //测试，
        System.out.println("测试深度遍历");
        graph.dfs();
    }
}
```







#### 图的广度优先遍历（BFS）

广度优先遍历的基本思想：类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点。



**王卓讲解**

从图的某一结点出发，首先依次访问该结点的所有邻接结点Vi1,Vi2,...再按这些顶点被访问的先后次序依次访问与他们相邻接的所有未被访问到的顶点。重复此过程，直到所有的顶点均被访问为止



**广度优先遍历的算法步骤**

1. 访问初试结点v并标记结点v已访问
2. 结点v入队列
3. 当队列非空时，继续执行，否则算法结束
4. 出队列，取得队头的结点u。
5. 查找结点u的第一个邻接结点w
6. 若结点u的邻接结点w不存在，则转到步骤3，否则执行以下三个步骤
   1. 若结点w尚未被访问，则访问结点w并标记为已访问
   2. 结点w入队
   3. 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6



```java
//对一个结点进行编写广度优先算法
private void bfs(boolean[] isVisited,int i){
    int u; //表示队列的头结点对应的下标
    int w; //邻接结点w
    //队列，结点访问的顺序
    LinkedList queue = new LinkedList();
    //访问结点，输出结点信息
    System.out.print(getValueByIndex(i) + "=>");
    //标记为已访问
    isVisited[i] = true;
    //将结点加入队列
    queue.addLast(i);

    while ( !queue.isEmpty()){
        //取出队列头结点的下标
         u = (Integer) queue.removeFirst();
         //得到第一个邻接结点的下标w
         w = getFirstNeighbor(u);
         while (w != -1){//找到
             //是否访问过
             if (!isVisited[w]){
                 System.out.print(getValueByIndex(w) + "=>");
                 //标记已经访问过
                 isVisited[w] = true;
                 //入队
                 queue.addLast(w);
             }
             //以u为前驱结点，找w后面的下一个邻接点
             //u是前一个结点，w是当前结点，方法找的是w后面的结点
             w = getNextNeighbor(u,w);//体现出我们的广度优先
         }
    }
}

//遍历所有的结点，都进行广度优先
public void bfs(){
    for (int i= 0;i < getNumOfVertex();i++){
        if (!isVisited[i]){
            bfs(isVisited,i);
        }
    }
}
```



------



## 算法部分

### 递归

递归的概念：递归就是方法自己调用自己，每次调用时传入不同的变量。递归有助于编程者解决复杂的问题，同时可以让代码变得简洁。



**两个小案例**

1. 打印问题
2. 阶乘问题

递归调用规则：

1. 当程序执行到一个方法时，就会开辟一个独立的空间（栈）

![image-20210521100500202](/Users/mac/Library/Application Support/typora-user-images/image-20210521100500202.png)

**递归能解决什么样的问题？**

1. 各种数学问题如：8皇后问题，汉诺塔问题，阶乘问题，迷宫问题，球和篮子的问题
2. 各种算法中也会使用到递归，比如：快排，归并查找，二分查找，分支算法等、
3. 将用栈解决的问题---->递归，代码比较简洁

**递归需要遵循的重要规则**

1. 执行一个方法的时候，就创建一个新的受保护的独立空间（栈空间）
2. 方法的局部变量是独立的，不会互相影响，比如n遍历
3. 如果方法中使用的是引用类型的变量，就会共享该引用类型的数据
4. 递归必须向退出递归的条件逼近，否则就无限递归了
5. 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。



**递归-迷宫回溯问题**



```java
public static void main(String[] args) {
    //先创建一个地图
    //8行7列，1表示墙
    int[][] map = new int[8][7];
    //设置墙
    for (int i = 0; i < 7; i++) {
        map[0][i] = 1;
        map[7][i] = 1;
    }
    for (int j = 0; j < 8; j++) {
        map[j][0] = 1;
        map[j][6] = 1;
    }
    //设置挡板
    map[3][1] = 1;
    map[3][2] = 1;

    System.out.println("---------------------------迷宫地图-------------------");
    //打印墙（遍历）
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 7; j++) {
            System.out.print(map[i][j] + " ");
        }
        System.out.println();
    }
    setWay2(map,1,1);
    System.out.println("---------------------------小球找过路后的地图-------");

    //打印墙（遍历）
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 7; j++) {
            System.out.print(map[i][j] + " ");
        }
        System.out.println();
    }


}
```

```java
//使用递归回溯来给小球找路
//说明:
//1.map表示地图
//2.i,j表示从地图的那个位置开始出发（i，j）
//3.如果小球能到map[6][5]位置，则说明通路找到了
//4、约定：当map[i][j]为0时，表示该点没有走过，当为1时表示墙，当为2时表示通路可以走，如果为3表示该位置已经走过，但是走不通
//5.在走迷宫时，需要确定一个策略（方法） 下->右->上->左  如果走不通，再回溯。

/**
 *
 * @param map 表示地图
 * @param i 从哪个位置开始找
 * @param j
 * @return 如果找到通路，就犯规true ，否则返回false
 */
public static boolean setWay(int[][] map,int i,int j) {
    if (map[6][5] == 2) {//表示通路已经找到
        return true;
    } else {//通路没有找到，开始寻找
        if (map[i][j] == 0) {//如果当前的点还没有走过
            map[i][j] = 2; //先假定这个点可以走通
            if (setWay(map, i - 1, j)) {//向下走
                return true;//如果能走通
            } else if (setWay(map, i, j + 1)) {//向右走
                return true;
            } else if (setWay(map, i + 1, j)) {//向下走
                return true;
            } else if (setWay(map, i, j - 1)) {//向左走
                return true;
            }else {//说明该点是死路
                map[i][j] = 3;
                return false;
            }
        } else {
            return false;
        }
    }
}
```

------



#### 八皇后问题：

是回溯算法的典型案例。该问题是在8x81格的国籍象棋上摆放八个皇后，使其不能相互攻击，即：**任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法**

使用回溯算法

八皇后算法的思路分析：

1. 第一个皇后先放第一行第一列
2. 第二个皇后放在第二行第一列、然后判断是否OK，如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适的
3. 继续第三个皇后，还是第一列、第二列.....。直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解。
4. 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到。
5. 然后回头继续第一个皇后放第二列，后面继续循环执行1、2、3的步骤。



说明：理论上应创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一位数组即可解决问题。

arr[8] = {0,4,7,5,2,6,1,3}//对应arr下标表示第几行，即第几个皇后。arr[i]  = val,val表示第i+1个皇后，放在第i+1行的第val+1列

------



#### 排序算法

排序算法也称排序，是将一组数据，依指定的顺序进行排列的过程。

排序的分类：

1. 内部排序：指将需要处理的所有数据都加载到内部存储器中进行排序
2. 外部排序法：数据量过大，无法全部加载到内存中，需要借助外部存进行排序
3. 常见的排序算法分类如下：

![image-20210528085237732](/Users/mac/Library/Application Support/typora-user-images/image-20210528085237732.png)

------



#### 算法的时间复杂度

度量一个程序（算法）执行时间的两种方法

1. 事后统计法（不准确）
2. 事前估算法

#### 时间频度

一个算法花费的时间与算法中语句执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)

![image-20210528090202027](/Users/mac/Library/Application Support/typora-user-images/image-20210528090202027.png)

![image-20210528090405662](/Users/mac/Library/Application Support/typora-user-images/image-20210528090405662.png)

![image-20210528090612794](/Users/mac/Library/Application Support/typora-user-images/image-20210528090612794.png)

![image-20210528090705804](/Users/mac/Library/Application Support/typora-user-images/image-20210528090705804.png)

#### 时间复杂度

1. 一般情况下：算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示。若某个辅助函数f(n)，🙆当n趋近于无穷大时，T(n)/f(n)的极限值为不等于0的常数，则称f(n)是T(n)的同数量级函数。记作T(n) = O(f(n))，称O(f(n))为算法的渐进时间复杂度，简称时间复杂度。

2. T(n)不同，但时间复杂度可能相同。![image-20210528091348155](/Users/mac/Library/Application Support/typora-user-images/image-20210528091348155.png)

   他们的T(n)不同，但时间复杂度相同，都是O(n²)

3. 计算时间复杂度的方法:

   1. 用常数1来代替运行时间中的所有加法常数
   2. 修改后的运行次数函数中，只保留常数项
   3. 去除最高阶项的次数



常见的时间复杂度（8个）

![image-20210528092016579](/Users/mac/Library/Application Support/typora-user-images/image-20210528092016579.png)



#### 平均时间复杂度和最坏时间复杂度

1. 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间
2. 最坏情况下的时间复杂度称为最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行的界限，这就保证了算法的运行时间不会比最坏情况更长。
3. 平均时间复杂度和最坏时间复杂度是否一致，和算法有关。
4. ![image-20210528093923099](/Users/mac/Library/Application Support/typora-user-images/image-20210528093923099.png)



#### 算法的空间复杂度

基本介绍：

1. 类似于时间复杂度的讨论：一个算法的空间复杂度（Space Complexity）定义为该算法所耗费的存储空间，它也是问题规模n的函数。
2. 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的度量。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况。
3. 在做算法分析的时候，主要讨论的是时间复杂度。从用户使用体验上看，更看重的是程序的执行速度。一些缓存产品（redis，memcache）和算法（基本排序）**本质就是用空间换时间**。



------



### 冒泡排序（Bubble Sorting）

冒泡排序的基本思路是：通过对待排序序列从前向后（从下标较小的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素从前向后移动，就像水底下的气泡一样逐渐上冒。

因为排序排序过程中各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设立一个flag标志判断元素是否进行过交换。从而减少不必要的比较。（优化）



![image-20210528100454121](/Users/mac/Library/Application Support/typora-user-images/image-20210528100454121.png)

小结冒泡排序规则：

1. 一共进行数组的大小-1次大的循环
2. 每一趟排序的次数在逐渐地减少
3. 如果我们发现在某趟排序中，没有发生一次交换，可以提交结束排序

**代码实现**

最基本的实现

```java
public static void main(String[] args) {
    int[] arr = {3, 9, -1, 10, -2};
    int temp = 0;
  //时间复杂度是O(n²)
    for (int i = 0; i < arr.length - 1; i++) {
      //这里的arr.length - 1 - i,意思是每一个元素都是一个泡泡，都需要冒一遍
        for (int j = 0; j < arr.length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
        System.out.println("第" + (i + 1) + "趟排序后的数组");
        System.out.println(Arrays.toString(arr));
    }
}
```

优化：在某趟没有发生交换的时候，说明已经排序好了，停止冒泡

```java
public static void main(String[] args) {
    int[] arr = {3, 9, -1, 10, 20};
    int temp = 0;
    boolean flag = false;//标识变量，表示是否进行过交换
    for (int i = 0; i < arr.length - 1; i++) {
        for (int j = 0; j < arr.length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                //进行交换了，把表示设为true
                flag = true;
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
        System.out.println("第" + (i + 1) + "趟排序后的数组");
        System.out.println(Arrays.toString(arr));

        if (!flag){//如果里面的循环走完了，都没有进行交换，说明里面已经拍好顺序了，直接退出
            break;
        }else {//如果循环走完一趟，发现有交换，再把flag重置，继续执行
            flag = false;
        }
    }
}
```

------



### 选择排序

选择排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。

**排序思想**

第一次从arr[0] -arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]-arr[n-1]中选取最小值，与arr[1]交换，以此类推，总共进行n-1次，得到一个从小到大排列的有序序列。

说明：

1. 选择排序一共有数组大小-1轮排序
2. 每1轮排序，又是一个循环
   1. 先假定当前的数是最小数
   2. 然后和后面的每一个数进行比较，如果发现有比当前数更小的数，就重新确定最小数，并得到下标
   3. 每遍历到数组的最后时，就得到本轮最小数和下标
   4. 交换



例子：有一群牛，颜值分别是101，34，119，1请使用选择排序从低到高进行排序

```java
public static void selectSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {//一共进行了arr.length -1 轮
        int minIndex = i;
        int min = arr[i];
        for (int j = i + 1; j < arr.length; j++) {//每一轮又是一个循环
            if (min > arr[j]) {//如果最小的这个数大于后面的数，重置最小值
                min = arr[j];
                minIndex = j;
            }
        }
        if (minIndex != i) {//其实min就相当于一个临时变量
            arr[minIndex] = arr[i];
            arr[i] = min;
        }
        //将最小值和当前比对的值进行交换

        System.out.println("第" + (i + 1) + "轮后");
        System.out.println(Arrays.toString(arr));
    }
}
```



经过试验，选择排序比冒泡排序块，80000个数据只需要2s

------



### 插入排序

插入排序属于内部排序法，是对欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。

**基本思想**

把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中又有一个元素，无序表中包含有n-1个元素，排序的过程中每次从无序表中取出第一个元素，把它的排序码依次与有序元素的排序码进行比较，将他插入到有序表中的适当位置，使之成为新的有序表。



例子：有一群牛，颜值分别是101，34，119，1请使用选择排序从低到高进行排序

```java
for (int i = 1; i < arr.length; i++) {
    int insertValue = arr[i];//要插入的值
    int insertIndex = i - 1;//插入的前一个值的索引
    while (insertIndex >= 0 && insertValue < arr[insertIndex]) {
        //把前一个后移
        arr[insertIndex + 1] = arr[insertIndex];
        insertIndex--;
    }
    arr[insertIndex + 1] = insertValue;
    System.out.println("第"+i+"轮排序后的结果为：");
    System.out.println(Arrays.toString(arr));
}
 /**

         //第一轮
         int insertValue = arr[1];//要插入的值
         int insertIndex = 1 -1;//插入的前一个值的索引

         //当要插入的前一个值的索引大于等于0，并且前面的值大于要插入的值的时候，开始交换
         //因为前面的都是有序的
         while (insertIndex >= 0 && insertValue < arr[insertIndex]){
         //把前一个后移
         arr[insertIndex + 1] = arr[insertIndex];
         insertIndex--;
         }
         arr[insertIndex + 1] = insertValue;
         System.out.println("第一轮排序后的结果为：");
         System.out.println(Arrays.toString(arr));

         insertValue = arr[2];
         insertIndex = 2 -1;

         while (insertIndex >= 0 && insertValue < arr[insertIndex]){
         //把前一个后移
         arr[insertIndex + 1] = arr[insertIndex];
         insertIndex--;
         }
         arr[insertIndex + 1] = insertValue;
         System.out.println("第2轮排序后的结果为：");
         System.out.println(Arrays.toString(arr));



         insertValue = arr[3];
         insertIndex = 3 -1;

         while (insertIndex >= 0 && insertValue < arr[insertIndex]){
         //把前一个后移
         arr[insertIndex + 1] = arr[insertIndex];
         insertIndex--;
         }
         arr[insertIndex + 1] = insertValue;
         System.out.println("第3轮排序后的结果为：");
         System.out.println(Arrays.toString(arr));
         */
```

![image-20210530203246008](/Users/mac/Library/Application Support/typora-user-images/image-20210530203246008.png)



------



### 希尔排序

希尔排序是希尔提出的，也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。

**基本思想**

希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分为一组，算法便终止。

![image-20210530204908917](/Users/mac/Library/Application Support/typora-user-images/image-20210530204908917.png)



例子：有一群小牛，考试成绩分别是{8,9,1,7,2,3,5,4,6,0}请从小到大排序，请分别使用

1. 希尔排序时，对有序序列在插入时采用交换法，并测试排序速度。
2. 希尔排序时，对有序序列在插入时采用移动法，并测试排序速度。





**代码实现**

(交换法)

```java
 //第一轮排序
    int temp = 0;
    for (int i = 5; i < arr.length; i++) {//分为5组
        for (int j = i - 5; j >= 0; j -= 5){//遍历每一组的数据
            if (arr[j] > arr[j+5]){
                temp = arr[j];
                arr[j] = arr[j+5];
                arr[j+5] = temp;
            }
        }
    }
    System.out.println("第1轮交换晚后的数据是");
    System.out.println(Arrays.toString(arr));

    //第二轮排序，分为两组
    temp = 0;
    for (int i = 2; i < arr.length; i++) {//分为5组
        for (int j = i - 2; j >= 0; j -= 2){//遍历每一组的数据
            if (arr[j] > arr[j+2]){
                temp = arr[j];
                arr[j] = arr[j+2];
                arr[j+2] = temp;
            }
        }
    }
    System.out.println("第2轮交换晚后的数据是");
    System.out.println(Arrays.toString(arr));
}
```



代码整合后（交换法）

```java
public static void shellSort(int[] arr) {
    int temp = 0;
    int count = 0;
    for (int gap = arr.length / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < arr.length; i++) {//分为5组
            for (int j = i - gap; j >= 0; j -= gap) {//遍历每一组的数据
                if (arr[j] > arr[j + gap]) {
                    temp = arr[j];
                    arr[j] = arr[j + gap];
                    arr[j + gap] = temp;
                }
            }
        }
        System.out.println("第" + (++count) + "轮交换晚后的数据是");
        System.out.println(Arrays.toString(arr));
    }
}
```



**算法改进（移位法）**

```java
public static void shellSort2(int[] arr) {
    for (int gap = arr.length / 2; gap > 0; gap /= 2) {
        //从第gap个元素开始，逐个对其所在的组进行直接插入排序
        for (int i = gap; i < arr.length; i++) {
            int j = i;
            int temp = arr[j];
            if (arr[j]<arr[j-gap]) {//直接插入排序
                while (j - gap >= 0 && temp < arr[j - gap]){
                  arr[j] = arr[j-gap];
                  j-=gap;
                }
                //当退出循环的时候，就给temp找到了放置的位置
                arr[j] = temp;
            }
        }
    }
}
```

------



### 快速排序

是对冒泡排序的一种改进。基本思想是：

通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

**代码实现**

```java
public static void quickSort(int[] arr, int left, int right) {
    int l = left;//左下标
    int r = right;//由下标

    //pivot 中轴值
    int pivot = arr[(left + right) / 2];
    int temp = 0;//交换时使用
    //while循环的目的是让比pivot值小的放到左边，
    //比pivot值大的放到右边
    while (l < r) {

        while (arr[l] < pivot) {
            //在pivot左边一直找，直到找到一个大于等于pivot的值
            l += 1;
        }
        while (arr[r] > pivot) {
            //在pivot右边一直找，直到找到一个小于等于pivot的值
            r -= 1;
        }
        //找到以后要干什么呢？交换
        if (l >= r) {//说明左右两边的值，已经按照左边小于等于pivot,右边全部是大于等于pivot的值
            break;
        }
        //交换
        temp = arr[l];
        arr[l] = arr[r];
        arr[r] = temp;

        //如果交换完了发现arr[l] == pivot值相等 ，那么就--，前移
        if (arr[l] == pivot) {
            r -= 1;
        }
        //如果交换完了发现arr[r] == pivot值相等 ，那么就--，前移
        if (arr[r] == pivot) {
            l += 1;
        }
    }
    if (l == r) {
        l += 1;
        r -= 1;
    }
    //向左递归
    if (left < r){
        quickSort(arr,left,r);
    }
    //向右递归
    if (l < right){
        quickSort(arr,l,right);
    }
}
```

------



### 归并排序

归并排序（MERGE-SORT‘）是利用归并的思想实现的排序方法，该算法采用经典的分治策略（分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案“修补”在一起，即分而治之）

![image-20210604101350062](/Users/mac/Library/Application Support/typora-user-images/image-20210604101350062.png)

![image-20210604101222361](/Users/mac/Library/Application Support/typora-user-images/image-20210604101222361.png)

------



### 基数排序

1. 基数排序属于”分配式排序“，又称”桶子发“或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些”桶“中，达到排序的作用
2. 基数排序法是属于稳定性的排序，基数排序法是效率高的稳定性排序法
3. 基数排序是桶排序的扩展
4. 基数排序是1887年赫尔曼·何乐发明的，它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较



**基数排序的基本思想**

1. 将所有待比较数值统一为同样的位数长度，数位较短的数前面补零。然后，从最低位开始，依次进行依次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成了一个有序数列
2. 图文解释a

![image-20210605170549066](/Users/mac/Library/Application Support/typora-user-images/image-20210605170549066.png)

![image-20210605170754707](/Users/mac/Library/Application Support/typora-user-images/image-20210605170754707.png)

![image-20210605170939895](/Users/mac/Library/Application Support/typora-user-images/image-20210605170939895.png)

![image-20210605171005284](/Users/mac/Library/Application Support/typora-user-images/image-20210605171005284.png)



**代码实现**

```java
public static void radixSort(int[] arr) {

    //先得到数组中最大的数的位数
    int max = arr[0];
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    //得到最大数的位是几位数
    int maxLength = (max + "").length();
    //定义一个二维数组，表示十个桶
    //说明：
    //1、二维数组包含10个一位数组
    //2、为了防止在放入数的时候，数据溢出，则每一个数组（桶）,大小为arr.length
    //3、明确：基数排序是适用空间换时间的经典排序
    int[][] bucket = new int[10][arr.length];

    //为了记录每个桶中，实际放了多少个数据，我们定义一个一位数组来记录各个桶每次放入的数据的个数
    //比如：bucketElementCounts[0],记录的就是bucket[0]桶的放入数据的个数
    int[] bucketElementCounts = new int[10];


    //开始循环
    for (int k = 0, n = 1; k < maxLength; k++, n *= 10) {//对大有几位就循环几次
        //第k轮，对个对应的数进行排序
        for (int j = 0; j < arr.length; j++) {
            int digitOfElement = arr[j] / n % 10;//   digitOfElement 每个元素的对应位数
            //第digitOfElement桶的第bucketElementCounts[digitOfElement]元素是arr[j]
            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
            //++的原因：如果下一次算出来的个位数还是digitOfElement，就让它放到下一个位置去
            bucketElementCounts[digitOfElement]++;//放进去以后放让存放
        }

        int index = 0;
        //依次把10个桶里面的数据放回到arr数组中
        for (int i = 0; i < bucketElementCounts.length; i++) {//遍历每一个桶
            if (bucketElementCounts[i] != 0) {
                //从第一个桶开始
                for (int j = 0; j < bucketElementCounts[i]; j++) {
                    arr[index++] = bucket[i][j];
                }
            }
            //第一轮处理后，需要将bucketElementCounts[i] = 0 !!!!!
            bucketElementCounts[i] = 0;
        }
        System.out.println("遍历完"+(k+1)+"位数后的结果=" + Arrays.toString(arr));
    }
}
```



注意事项：如果数据量比较大，可能会造成内存溢出！

------



### 常用排序算法的总结和对比

常用术语：

1. 稳定：如果原本a在前面，而a=b，排序之后a仍然在b的前面
2. 不稳定：与稳定相反
3. 内排序：所有排序操作都是在内存中完成的
4. 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行
5. 时间复杂度：一个算法执行所消耗的时间
6. 空间复杂度：运行完一个程序所需要的内存的大小
7. n:数据的规模
8. k:”桶的个数“
9. In-place:不占用额外内存
10. Out-place:占用额外内存

![image-20210605182108683](/Users/mac/Library/Application Support/typora-user-images/image-20210605182108683.png)



------



### 查找算法

在Java中，我们常用的查找有四种：

1. 顺序（线性）查找
2. 二分查找/折半查找
3. 插值查找
4. 斐波那契查找

------



### 线性查找

有一个数列{1,8,10,89,1111,1234},判断数列中是否包含此名称{顺序查找}，要求：如果找到了，就提示找到，并给出下标值。

思路：如果查找到全部符合条件的值

**代码实现**

线性查找就是遍历

```java
public static int seqSearch(int[] arr,int value){
    for (int i = 0;i < arr.length;i++){
        if (arr[i] == value){
            return i;
        }
    }
    return -1;
}
```

------



### 二分查找法

二分查找：请对一个有序数组进行二分查找{1,8,10,89,1000,1234},请输入一个数看看该数组是否存在次数，并且求出下标，如果没有就提示”没有这个数“。



思路分析：

1. 首先确定该数组在中间下标

   mid = (left + right) / 2

2. 然后让需要查找的数findVal和arr[mid]比较

   1 findVal > arr[mid]，说明你要查找的数在mid的右边，因此需要递归的向右查找

   2 findVal < arr[mid]，说明你要查找的数在mid的左边，因此需要递归的向左查找

   3 findVal = arr[mid]，说明找到，就返回

   

   什么时候需要退出递归

   1. 找到就结束递归
   2. 递归完整个数组，仍然没有找到findVal,也需要结束递归 当left > right 就需要退出

   

   **代码实现**

   ```java
   /**
    * @param arr     数组
    * @param left    左边的索引
    * @param right   右边的索引
    * @param findVal 要查找的数
    * @return 如果找到就返回索引，找不到就返回-1
    */
   public static int binarySearch(int[] arr, int left, int right, int findVal) {
       if (left > right) {
           return -1;
       }
       int mid = (left + right) / 2;
       int midValue =arr[mid];
   
       if (findVal > midValue) {//向右递归
           return  binarySearch(arr, mid + 1, right, findVal);
       } else if (findVal < midValue) {//向左递归
          return binarySearch(arr, left, mid - 1, findVal);
       } else {
           return mid;
       }
   }
   ```

   

**代码完善，有多个相同值的时候**

```java
public static ArrayList<Integer> binarySearch2(int[] arr, int left, int right, int findVal) {
    if (left > right) {
        return new ArrayList<Integer>();
    }
    int mid = (left + right) / 2;
    int midValue = arr[mid];

    if (findVal > midValue) {//向右递归
        return binarySearch2(arr, mid + 1, right, findVal);
    } else if (findVal < midValue) {//向左递归
        return binarySearch2(arr, left, mid - 1, findVal);
    } else {
        ArrayList<Integer> resIndexList = new ArrayList<Integer>();
        int temp = mid - 1;
        while (true) {
            if (temp < 0 || arr[temp] != findVal) {//退出
                break;
            }
            resIndexList.add(temp);
            temp -= 1;  //temp左移
        }
        resIndexList.add(mid);

        temp = mid + 1;
        while (true) {
            if (temp > arr.length - 1 || arr[temp] != findVal) {//退出
                break;
            }
            resIndexList.add(temp);
            temp += 1;
        }
        return resIndexList;
    }

}
```

------



### 插值查找算法

原理介绍：

1. 插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找

2. 将折半查找中的求mid索引的公式，low表示左边索引，hight表示右边索引。

   这里的key指的是我们要查找的值

   ![image-20210606160001074](/Users/mac/Library/Application Support/typora-user-images/image-20210606160001074.png)

   int midIndex = low + (higt -low) *(key -arr[low])/(arr[high] - arr[low])

   对应前面的代码公式：

   int mid = left + (right - lrft) * (findVal - arr[left]) / (arr[right] - arr[left])

   

   **代码实现**

   ```java
   /**
    * @param arr       传入的数组
    * @param left      左边的索引
    * @param right     右边的索引
    * @param findValue 查找值
    * @return 如果找到，就返回对应的下标，如果没有找到，就返回-1
    */
   public static int insertValueSearch(int[] arr, int left, int right, int findValue) {
       System.out.println("调用依一次");
   
       if (left > right) {
           return -1;
       }
       int mid = left + (right - left) * (findValue - left) / (arr[right] - arr[left]);
       int midValue = arr[mid];
   
       if (findValue > midValue) {//向右递归
           return insertValueSearch(arr, mid + 1, right, findValue);
       } else if (findValue < midValue) {
           return insertValueSearch(arr, left, mid - 1, findValue);
       }else {
           return mid;
   
       }
   }
   ```

3. 注意：

    对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找，速度较快。

   关键字分布不均匀的情况下，该方法不一样比折半查找好。

------



### 斐波那契（黄金分割）查找算法

**基本介绍**

1. 黄金分割点是指把一条线段分割成两个部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是0.618.由于按此比例设计的造型十分美丽，因此成为黄金分割，也称为中外比。这是一个神奇的数字，会带来意想不到的效果
2. 斐波那契数列{1,1,2,3,5,8,13,21,34,55}发现斐波那契数列的两个相邻数的比例，无限接近黄金分割值0.618。

**斐波那契（黄金分割法）原理**

1. 斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即 mid = low + F(k-1) -1

2. **对F(k-1) -1的理解**：由斐波那契数列F(k) = F(k-1) +  F(k-2) ,可以得到(F(k)-1) = (F(k-1)-1) + ( F(k-2)-1) +1。该式说明：只要顺序表的长度是F(k) -1，就可以将该表分成长度为                     F(k-1)-1和F(k-2)-1的两段，即如下所示。从而中间位置为mid = low + F(k-1) - 1。

   这里的mid就像是一份

例如：（F(6) -1） = （F(5)-1）+ 1 + （F(4)-1）==> 12 = 7 + 1(mid) + 4

![image-20210607104605055](/Users/mac/Library/Application Support/typora-user-images/image-20210607104605055.png)

类似的，每一子段也可以用相同的方式分割

但顺序表长度n不一定刚好等于F(k) -1，所以需要将原来的顺序表长度n增加至F(k)-1。这里的k值只要能使得F(k)-1恰好大于或等于n即可，由以下代码得到，顺序表长度增加后，新增的位置（从n+1到F(k)-1位置），都赋给n位置即可。

------



### 程序员常见的10种算法

------



#### 二分查找算法（非递归）

1. 二分查找法只适用于从有序的数列中进行查找（比如数和字母等），将数列排序后再进行查找
2. 二分查找法的运行时间为对数时间O(log2n),即查找到需要的目标位置最多只需要log2n步（假设0-99的队列，100个数，寻找到目标30，只需要log2100,即最多需要查找7次）



```java
public static int binarySearch(int[] arr, int target) {
    int left = 0;
    int right = arr.length - 1;
    while (left <= right) {
        int mid = (left  + right)  /2;
        if (arr[mid] == target){
            return mid;//如果正好等于则返回
        }else if(arr[mid] > target){//如果中间值大于目标值
            right = mid - 1;//向左边找
        }else {
            left = mid + 1;
        }
    }
    return -1;
}
```



------



#### 分治算法

1. 即分而治之，把一个复杂的问题分解成很多个相同或类似的子问题，这个算法是很多高效算法的基础。
2. 分治算法可以求解一些经典的问题
   1. 二分搜索
   2. 大整数乘法
   3. 棋盘覆盖
   4. 合并排序
   5. 快速排序
   6. 线性时间选择
   7. 最接近点对问题
   8. 循环赛日程表
   9. **汉诺塔**

**分治算法的步骤**

1. 分解：将原问题分解称为若干个规模较小，互相独立，与原问题形式相同的子问题
2. 解决：若子问题规模较小而容易被解决则直接解决，某族递归地解决各个子问题
3. 合并：将各个子问题的解合并为原问题的解



![image-20210816151148346](/Users/mac/Library/Application Support/typora-user-images/image-20210816151148346.png)

**思路分析**

1. 如果只有一个盘 A -> C

   如果有n >=2情况，我们总是可以看做是两个盘子：1、最下面的盘。2、上面的所有盘

   1）先把最上面的盘 A->B

   2）把最下面的盘A->C

   3）把B塔的所有盘从B -> C



```java
public static void hanoiTower(int num, char a, char b, char c) {
    //如果只有一个盘
    if (num == 1) {
        System.out.println("第1个盘从" + a + "->" + c);
    } else {
        //如果有n >=2情况，我们总是可以看做是两个盘子：1、最下面的盘。2、上面的所有盘
        //1）先把最上面的盘 A->B
        hanoiTower(num - 1, a, c, b);
        //2）把最下面的盘A->C
        System.out.println("第" + num + "个盘从" + a + "->" + c);
        //3）把B塔的所有盘从B -> C
        hanoiTower(num - 1, b, a, c);
    }
}
```

------



#### 动态规划（Dnamic Programming）

应用场景-背包问题：有一个背包，容量为4磅，现有如下物品：

![image-20210816153858307](/Users/mac/Library/Application Support/typora-user-images/image-20210816153858307.png)

1. 要求达到目标为装入的背包总价值最大，并且重量不超出
2. 要求装入的物品不能重复

**动态规划算法介绍**

1. 将待求解问题分解成若干个子问题，先求子问题，然后从这些子问题的解得到原问题的解。
2. 与分治算法不同的是，适合于动态规划求解的问题，经分解得到的子问题往往不是互相独立的。（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步求解）
3. 动态规划可以通过填表的方式来逐步推进，得到最优解。



**思路分析和图解**

- 背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分为01背包和完全背包（完全背包指的是：每种物品都有无限件可以用）
- 这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包。
- **算法的主要思想**：每次遍历到的第i个物品，根据w[i]  (第i个物品的重量)和v[i]  (第i个物品的价值)来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]  w[i]分别为物品的价值和重量，C为背包的容量。再令v[i] [j]表示在前i个物品中能够装入容量为j的背包中的最大价值。

![image-20210816160543568](/Users/mac/Library/Application Support/typora-user-images/image-20210816160543568.png)



1. v[i] [0] = v[0] [j] = 0;   //表示填入表的一行和第一列是0

2. 当w[i] > j时：v[i] [j] = v[i-1] [j] //当准备加入新增的商品的重量大于当前背包的容量，就直接使用上面单元格的装入策略。

3. 当j >= w[i]时：v[i] [j] = max{v[i-1] [j],v[i]+v[i-1] [j-w[i]]}  

   //当准备加入的新增的商品的容量小于等于当前背包的容量时

   //装入的方式：

   v[j-1] [j] : 就是上一个单元格的装入的最大值

   v[i]：表示当前商品的价值

   v[i-1] [j-w[j]]:装入i-1商品，到剩余空间j-w[i]

   **具体说明**

   v[3] [4]  : i = 3  , j = 4   ----->装第3个物品到空间为4的背包

   w[i] = w[3] = 3 j = 4

   j = 4 >=w[i] = 3 = >4 >=3

   

   ```java
   public static void main(String[] args) {
           int[] w = {1, 4, 3};//物品的重量
           int[] val = {1500, 3000, 2000};//物品的价值
           int m = 4;//背包的容量
           int n = val.length;//物品的个数
   
           //创建二维数组
           //v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值
           int[][] v = new int[n + 1][m + 1];
           int[][] path = new int[n + 1][m + 1];
   
           //初始化第一列
           for (int i = 0; i < v.length; i++) {
               v[i][0] = 0;
           }
           //初始化第一行
           for (int i = 0; i < v[0].length; i++) {
               v[0][i] = 0;
           }
   
           //根据前面的公式进行动态规划处理
           for (int i = 1; i < v.length; i++) {//不处理第一行
               for (int j = 1; j < v[0].length; j++) {//不处理第一列
                   if (w[i - 1] > j) {//如果放入物品的重量大于背包容量
                       v[i][j] = v[i - 1][j];//就还放上一个物品
                   } else {
   //                    v[i][j] = Math.max(v[i-1][j],val[i-1] + v[i-1][j-w[i-1]]);
                       if (v[i - 1][j] < val[i - 1] + v[i - 1][j - w[i - 1]]) {
                           //为了记录商品存放到背包的问题
                           v[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]];
                           path[i][j] = 1;
                       }else {
                           v[i][j] = v[i - 1][j];
                       }
                   }
               }
           }
   
           //输出一下表格
           for (int i = 0; i < v.length; i++) {
               for (int j = 0; j < v[0].length; j++) {
                   System.out.print(v[i][j] + " ");
               }
               System.out.println();
           }
   
   
           int i = path.length -1; //行的最大下标
           int j = path[0].length -1;//列的最大下标
   
           while (i > 0 && j > 0){//从path数组最后开始找
               if (path[i][j] == 1){
                   System.out.printf("第%d个商品放入背包\n",i);
                   j -= w[i-1];
               }
               i--;
           }
   
       }
   ```

   ------

   

#### KMP算法

字符串匹配问题：

1. 有一个字符串 str1 = "尚硅谷，尚硅谷你尚硅 山上硅谷你尚硅谷好"和一个子串str2 = "尚硅谷你尚硅谷"
2. 现在要判断str1是否含有str2，如果存在，就返回第一次出现的位置，如果没有，则返回-1



暴力匹配算法（不用）

1. 如果当前字符串匹配成功（即str1[i]==str2[j]），则i++，j++，继续匹配下一个字符
2. 如果匹配失败（即str1[i] != str2[j]）,令i = i-(j-1), j = 0.  相当于每次匹配失败时，i回溯，j被置零。**理解：从第i个位置往后回退str2已经匹配到的字符-1的位置**
3. ![image-20210816173925803](/Users/mac/Library/Application Support/typora-user-images/image-20210816173925803.png)
4. 用暴力方法解决的话有大量的回溯，每次只移动一位，若是不匹配，移动到下一位继续判断。浪费了大量的时间



```java
public static int violenceMatch(String str1, String str2) {
    char[] s1 = str1.toCharArray();
    char[] s2 = str2.toCharArray();

    int str1Length = s1.length;
    int str2Length = s2.length;

    int i = 0;
    int j = 0;
    //暴力匹配
    while (i < str1Length && j < str2Length) {//没有越界的情况下
        if (s1[i] == s2[j]) {//如果匹配
            i++;
            j++;
        } else {
            i = i - (j - 1);
            j = 0;
        }
    }
    if (j == str2Length) {
        return i - j;
    } else {
        return -1;
    }
}
```



KMP算法介绍

1. KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现位置的经典算法。
2. KMP算法就利用之前判断过的信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置。

![image-20210816175554361](/Users/mac/Library/Application Support/typora-user-images/image-20210816175554361.png)

![image-20210816175651506](/Users/mac/Library/Application Support/typora-user-images/image-20210816175651506.png)





![image-20210816180524249](/Users/mac/Library/Application Support/typora-user-images/image-20210816180524249.png)

![image-20210816180638603](/Users/mac/Library/Application Support/typora-user-images/image-20210816180638603.png)

注意：部分匹配值表的值指的是，共有元素的长度最长的那个数



![image-20210816232004164](/Users/mac/Library/Application Support/typora-user-images/image-20210816232004164.png)

遇到不匹配的时候，让公共前缀来到公共后缀的位置，这样前面公共部分的肯定是匹配的。





```java
public class KMPAlgorithm {
    public static void main(String[] args) {
        String str1 = "BBC ABCDAB ABCDABCDABDE";
        String str2 = "ABCDABD";

        int[] next = kmpNext("ABCDABD");
        System.out.println("next=" + Arrays.toString(next));


        int index = kmpSearch(str1, str2, next);
        System.out.println("index = " + index);
    }

    //KMP搜索算法

    /**
     * @param str1 源字符串
     * @param str2 模式串
     * @param next 部分匹配表，是对应模式串的部分匹配表
     * @return 如果是-1就没匹配到
     */
    public static int kmpSearch(String str1, String str2, int[] next) {
        //遍历
        for (int i = 0, j = 0; i < str1.length(); i++) {
            //需要考虑str1.charAt(i) != str2.charAt(j)
            //kmp的核心点
            while (j > 0 && str1.charAt(i) != str2.charAt(j)){
                j = next[j-1];
            }

            if (str1.charAt(i) == str2.charAt(j)) {
                j++;
            }

            if (j == str2.length()) {
                return i - j + 1;
            }
        }
        return -1;
    }

    //获取到一个字符串（子串）的部分匹配值表
    public static int[] kmpNext(String dest) {
        //首先创建一个next数组 保存部分匹配值
        int[] next = new int[dest.length()];
        next[0] = 0;//如果字符串长度是1 部分匹配值就是0
        for (int i = 1, j = 0; i < dest.length(); i++) {
            //这里的i是后缀的末尾，j是前缀的末尾也代表包括i之前子串的最长相等前后缀的长度
            //当dest.charAt(i) != dest.charAt(j)时,需要从next[j-1]获取新的j
            //直到我们发现有 dest.charAt(i) == dest.charAt(j)时成立才退出
            //这是kmp算法的一个核心点
            while (j > 0 && dest.charAt(i) != dest.charAt(j)) {
                j = next[j - 1];
            }
            //满足这个条件dest.charAt(i) == dest.charAt(j)时，部分匹配值就+1
            if (dest.charAt(i) == dest.charAt(j)) {
                j++;
            }
            next[i] = j;
        }
        return next;
    }
}
```





#### 贪心算法

应用场景-集合覆盖问题：

假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区。如何选择最少的广播台，让所有的地区都可以接受到信号？

![image-20210817145728263](/Users/mac/Library/Application Support/typora-user-images/image-20210817145728263.png)



**贪心算法**

1. 贪心算法是指在堆问题进行求解时，在每一步选择中都采取最好或最优的选择，从而希望能够导致结果是最好或者最优的算法。
2. 贪心算法所得到的结果不一定就是最优的结果（有时候会是最优解），但是都是相对接近（近似）最优解的结果。

**思路分析**

1. 遍历所有的广播电台，找到一个覆盖了最多未覆盖的地区的电台（可能包含一些已经覆盖的地区）
2. 将这个电台加入到一个集合中（ArrayList）想办法把该电台覆盖的地区在下一次比较时去掉
3. 重复1步骤直到覆盖了全部的地区



```java
public class GreedyAlgorithm {
    public static void main(String[] args) {
        //创建广播电台，放到Map里
        HashMap<String, HashSet<String>> broadcasts = new HashMap<String,HashSet<String>>();
        HashSet<String> hashSet1 = new HashSet<>();
        hashSet1.add("北京");
        hashSet1.add("上海");
        hashSet1.add("天津");

        HashSet<String> hashSet2 = new HashSet<>();
        hashSet2.add("广州");
        hashSet2.add("北京");
        hashSet2.add("深圳");

        HashSet<String> hashSet3 = new HashSet<>();
        hashSet3.add("成都");
        hashSet3.add("上海");
        hashSet3.add("杭州");

        HashSet<String> hashSet4 = new HashSet<>();
        hashSet4.add("上海");
        hashSet4.add("天津");

        HashSet<String> hashSet5 = new HashSet<>();
        hashSet5.add("杭州");
        hashSet5.add("大连");

        //加入到Map
        broadcasts.put("k1",hashSet1);
        broadcasts.put("k2",hashSet2);
        broadcasts.put("k3",hashSet3);
        broadcasts.put("k4",hashSet4);
        broadcasts.put("k5",hashSet5);

        //存放所有的地区
        HashSet<String> allAreas = new HashSet<>();
        allAreas.add("北京");
        allAreas.add("上海");
        allAreas.add("天津");
        allAreas.add("广州");
        allAreas.add("成都");
        allAreas.add("杭州");
        allAreas.add("大连");
        allAreas.add("深圳");

        //创建一个ArrayList，存放选择的电台集合
        ArrayList<String> selects = new ArrayList<>();

        //定义一个临时的集合，在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集
        HashSet<String> tempSet = new HashSet<>();

        //定义一个maxKey,保存在一次遍历中，能够覆盖最大未覆盖地区电台
        String maxKey = null;
        while (allAreas.size() != 0){
            maxKey = null;
            //遍历broadcasts,取出对应的key
            for (String key:broadcasts.keySet()) {
                tempSet.clear();
                HashSet<String> areas = broadcasts.get(key);
                tempSet.addAll(areas);
                //求tempSet 和 allAreas集合的交集，交集会赋给tempSet
                //意思及就是把这个电台能覆盖的地区放到了tempSet里
                //走到这步，tempSize里放的是，当前电台实际还能覆盖的地区
                tempSet.retainAll(allAreas);
                //如果当前这个集合包含的未覆盖地区的数量，比maxKey指向的集合地区还多
                //就需要重置maxKey
                if (tempSet.size() > 0 &&
                        (maxKey == null ||
                        tempSet.size() > broadcasts.get(maxKey).size())){
                    //当前的和最大那个比，如果比最大指向还打，就交换角色
                    maxKey = key;
                }
            }
            //如果maxKey不是空的，就应该将maxKey放入到selects中
            if (maxKey != null){
                selects.add(maxKey);
                //将maxKey指向的电台覆盖的地区，从allAreas去掉
                allAreas.removeAll(broadcasts.get(maxKey));
            }
        }
        System.out.println("得到的选择结果是" + selects);


    }
}
```



#### 普利姆算法（Prim）

应用场景

![image-20210817221533763](/Users/mac/Library/Application Support/typora-user-images/image-20210817221533763.png)

**思路：**

尽可能选择少的路线，并且每条路线最小，才能保证总里程数最少。

修路问题的本质就是**最小生成树问题(MST)**

1. 给定一个带权的无项连通图,如何选取一颗生成树,使树上所有边权的总和为最小.
2. N个顶点，一定有N-1条边
3. 包含全部顶点
4. N-1条都在图中
5. 求最小生成树的算法主要有：**普利姆算法和克鲁斯卡尔算法**



**普里姆算法**

![image-20210817222309805](/Users/mac/Library/Application Support/typora-user-images/image-20210817222309805.png)

**图解**

![image-20210817222953040](/Users/mac/Library/Application Support/typora-user-images/image-20210817222953040.png)





```java
public class Prim {
    public static void main(String[] args) {
        char[] data = {'A','B','C','D','E','F','G'};
        int vertx = data.length;
        //邻接矩阵的关系用二维数组表示
        int[][] weight = new int[][]{
                {10000,5,7,10000,10000,10000,2},
                {5,10000,10000,9,10000,10000,3},
                {7,10000,10000,10000,8,10000,10000},
                {10000,9,10000,10000,10000,4,10000},
                {10000,10000,8,10000,10000,5,4},
                {10000,100000,10000,4,5,10000,6},
                {2,3,10000,10000,4,6,10000},
        };

        //创建图对象
        MGraph graph = new MGraph(vertx);
        MinTree minTree = new MinTree();
        minTree.createGraph(graph,vertx,data,weight);
//        minTree.showGraph(graph);
        minTree.prim(graph,0);
    }
}

class MinTree {
    public void createGraph(MGraph graph, int vertx, char data[], int[][] weight) {
        int i, j;
        for (i = 0; i < vertx; i++) {
            graph.data[i] = data[i];
            for (j = 0;j < vertx;j++){
                graph.weight[i][j] = weight[i][j];
            }
        }
    }

    //显示图
    public void showGraph(MGraph graph){
        for (int[] link : graph.weight){
            System.out.println(Arrays.toString(link));
        }
    }

    //编写prim算法，得到最小生成树

    /**
     * @param graph 图
     * @param v 表示从图的第几个顶点开始生成
     */
    public void prim(MGraph graph,int v){
        int[] visited = new int[graph.weight.length];

        //把当前这个结点标记为已访问
        visited[v] = 1;
        //h1 h2 记录两个顶点的下标
        int h1= -1;
        int h2= -1;
        int minWeight = 10000;

        for (int k = 1; k < graph.vertx; k++) {
            for (int i = 0; i < graph.vertx; i++) { //i结点表示已访问过的结点
                for (int j = 0; j < graph.vertx; j++) { //j结点表示未访问过的结点
                    if (visited[i] == 1 && visited[j] == 0 && graph.weight[i][j]< minWeight){
                        minWeight = graph.weight[i][j];
                        h1 = i;
                        h2 = j;
                    }
                }
            }
            //找到一条边是最小的
            System.out.println("边<" + graph.data[h1] + "," + graph.data[h2] + "> 权值" + minWeight);
            //将当前结点标记为已访问
            visited[h2] = 1;
            minWeight = 10000;
        }
    }
}

class MGraph {
    int vertx;//表示图的节点的个数
    char[] data;//存放结点数据
    int[][] weight;//存放边，即邻接矩阵

    public MGraph(int vertx) {
        this.vertx = vertx;
        data = new char[vertx];
        weight = new int[vertx][vertx];
    }
}
```





#### 克鲁斯卡尔（Kruskal）算法

![image-20210818092801011](/Users/mac/Library/Application Support/typora-user-images/image-20210818092801011.png)

**算法介绍**

1. 基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路
2. 具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直到森林变成一棵树为止。

**重点解决问题**

1. 对所有边按照权值大小进行排序。
2. 将边添加到最小生成树时，怎样判断是否形成了回路？

**我们加入的边的两个顶点不能都指向同一个终点，否则将构成回路**

![image-20210818102440028](/Users/mac/Library/Application Support/typora-user-images/image-20210818102440028.png)





```java
public class Kruskal {
    private int edgeNum;//边的个数
    private char[] vertex;//顶点数组
    private int[][] matrix;//邻接矩阵，表示顶点关系（权值）
    //用INF 表示两个顶点不能连通
    private static final int INF = Integer.MAX_VALUE;

    public static void main(String[] args) {

        char[] vertexs = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        //克鲁斯卡尔的邻接矩阵，表示边之间的关系
        //0表示自己和自己，INF表示不连通
        int[][] matrix = {
                {0, 12, INF, INF, INF, 16, 14},
                {12, 0, 10, INF, INF, 7, INF},
                {INF, 10, 0, 3, 4, 5, INF},
                {INF, INF, 3, 0, 4, INF, INF},
                {INF, INF, 5, 4, 0, 2, 8},
                {16, 7, 6, INF, 2, 0, 9},
                {14, INF, INF, INF, 8, 9, 0},
        };

        //创建一个实例
        Kruskal kruskal = new Kruskal(vertexs, matrix);
        kruskal.print();

      EData[] edges =   kruskal.getEdges();
        //没有排序
        System.out.println("排序前 = " + Arrays.toString(edges));
        //排序后
        kruskal.sortEdges(edges);
        System.out.println("排序后 = " + Arrays.toString(edges));

        kruskal.Kruskal();

    }

    //构造器
    public Kruskal(char[] vertex, int[][] matrix) {
        //初始化顶点数和边的个数
        int vlen = vertex.length;

        //初始化顶点,采用的是复制拷贝的方式
        this.vertex = new char[vlen];
        for (int i = 0; i < vertex.length; i++) {
            this.vertex[i] = vertex[i];
        }

        //初始化边,使用的是复制拷贝的方式
        //二维矩阵的行和列就是顶点的个数
        this.matrix = new int[vlen][vlen];
        for (int i = 0; i < vlen; i++) {
            for (int j = 0; j < vlen; j++) {
                this.matrix[i][j] = matrix[i][j];
            }
        }
        //统计边
        //遍历这个邻接矩阵，拿掉里面不连通的边
        for (int i = 0; i < vlen; i++) {
            for (int j = i+1; j < vlen; j++) {//这里的i+1意思是自己和自己没有必要互相连接了
                if (this.matrix[i][j] != INF) {//有效边，也就是连着的
                    edgeNum++;
                }
            }
        }

    }

    //算法开始
    public void Kruskal(){
        int index = 0;//表示最后结果数组的索引，结果数组里有多少条边
        int[] ends = new int[edgeNum];//用于保存"已有最小生成树"中每个顶点在最小生成树中的终点
        //创建结果数组，保存最后的最小生成树
        EData[] rets = new EData[edgeNum];

        //获取图中所有边的集合
        EData[] edges = getEdges();

        //1、首先按照边的权值大小排序，从小到大
        sortEdges(edges);

        //遍历edges数组，将边添加到最小生成树，判断准备加入的边是否形成了回路，如果没有就加入
        for (int i = 0; i < edgeNum; i++) {//所有的边都获取一下
            //获取到第i条边的第一个顶点（起点）
            int p1 = getPosition(edges[i].start);
            //获取到第i条边的第二个顶点（终点）
            int p2 = getPosition(edges[i].end);

            //获取p1这个顶点在已有最小生成树中的终点
            int m = getEnd(ends,p1);
            //获取p2这个顶点在已有最小生成树中的终点
            int n = getEnd(ends,p2);

            //是否构成回路
            if (m !=n){//没有构成回路
                ends[m] = n;//设置m在"已有最小生成树中"中的终点
                rets[index++] = edges[i];//有一条边加入到结果里
            }
        }
        for (int i = 0; i < index; i++) {
             System.out.println("最小生成树为=" + rets[i]);
        }


    }


    //打印邻接矩阵
    public void print() {
        System.out.println("邻接矩阵为：");
        for (int i = 0; i < vertex.length; i++) {
            for (int j = 0; j < vertex.length; j++) {
                System.out.printf("%12d\t", matrix[i][j]);
            }
            System.out.println();
        }
    }

    //对边进行排序处理，冒泡
    private void sortEdges(EData[] edges) {
        for (int i = 0; i < edges.length - 1; i++) {
            for (int j = 0; j < edges.length - 1 - i; j++) {
                if (edges[j].weight > edges[j + 1].weight) {//交换
                    EData temp = edges[j];
                    edges[j] = edges[j + 1];
                    edges[j + 1] = temp;
                }
            }
        }
    }

    //传入顶点的值，返回顶点的下标，如果找不到返回-1
    private int getPosition(char ch) {
        for (int i = 0; i < vertex.length; i++) {
            if (vertex[i] == ch) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 功能：获取图中的边，放到EData[]数组中，后面需要遍历该数组
     * 是通过matrix 邻接矩阵来获取
     * EData[] 形式：[['A','B',12],['B','F',7]]
     * @return
     */
    private EData[] getEdges(){
        int index = 0;
        EData[] edges = new EData[edgeNum];
        //遍历这个邻接矩阵
        for (int i = 0; i < vertex.length; i++) {
            for (int j = i+1; j < vertex.length; j++) {//i+1跳过自己
                if (matrix[i][j] != INF){//如果这个边是有权值的，说明是有边的
                    //则把这个边放到新建的这个数组中去
                    edges[index++] = new EData(vertex[i],vertex[j],matrix[i][j]);
                }
            }
        }
        return edges;
    }

    /**
     * 功能：获取下标为i的顶点的终点，用于后面判断两个顶点的终点是否相同
     * @param ends 数组记录了各个顶点对应的终点是哪个？ ends数组是在遍历过程中，逐步形成的
     * @param i 传入的顶点对应的下标
     * @return 返回的就是 下标为i的这个顶点对应的终点的下标
     */
    //这里是难点
    private int getEnd(int[] ends,int i){
        while (ends[i] != 0){
            i = ends[i];
        }
        return i;
    }
}

//创建一个边类，它的对象实例表示一条边
//方便对边进行大小排序
class EData {
    char start;//边的一个点
    char end;//边的另外一个点
    int weight;//边的权值

    public EData(char start, char end, int weight) {
        this.start = start;
        this.end = end;
        this.weight = weight;
    }

    //重新toString,便于输出
    @Override
    public String toString() {
        return "EData{" +
                "<" + start +
                ", " + end +
                ">=" + weight +
                '}';
    }
}
```





#### 迪杰斯特拉算法

应用场景-最短路径问题

![image-20210818145453833](/Users/mac/Library/Application Support/typora-user-images/image-20210818145453833.png)



**主要特点**

是以起始点为中心层层向外扩展（广度优先搜索思想），直到扩展到终点为止

**算法过程**

设置出发点v，顶点集合V{v1,v2,vi,....},  v 到 V中各顶点的距离构成距离集合Dis。Dis{d1,d2,di,...}，Dis集合记录着v到图中各顶点的距离（自身可看做0，v到vi距离对应为di）

1. 从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi，此时的v到vi即为最短路径
2. 更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到到V集合中顶点的距离值，保留值较小的一个（同时也应该更新顶点的前驱结点为vi，表明是从vi到达的）
3. 重复执行前两步骤，直到最短路径顶点为目标顶点即可结束。



![image-20210818223237360](/Users/mac/Library/Application Support/typora-user-images/image-20210818223237360.png)

![image-20210818223345689](/Users/mac/Library/Application Support/typora-user-images/image-20210818223345689.png)





```java
public class DijkstraAlgorithm {
    public static void main(String[] args) {
        char[] vertex = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        int[][] matrix = new int[vertex.length][vertex.length];
        final int N = 65535;
        matrix = new int[][]{
                {N, 5, 7, N, N, N, 2},
                {5, N, N, 9, N, N, 3},
                {7, N, N, N, 8, N, N},
                {N, 9, N, N, N, 4, N},
                {N, N, 8, N, N, 5, 4},
                {N, N, N, 4, 5, N, 6},
                {2, 3, N, N, 4, 6, N}
        };
        //创建Graph对象
        Graph graph = new Graph(vertex, matrix);
        graph.showGraph();

        graph.dsj(6);
        graph.showDjkstra();
    }
}

class Graph {
    private char[] vertex;//顶点数组
    private int[][] matrix;//邻接矩阵
    private VisitedVertex vv;//已经访问的顶点的集合

    //构造器
    public Graph(char[] vertex, int[][] matrix) {
        this.vertex = vertex;
        this.matrix = matrix;
    }

    //显示图
    public void showGraph() {
        for (int[] link : matrix) {
            System.out.println(Arrays.toString(link));
        }
    }

    //显示结果
    public void showDjkstra() {
        vv.show();

    }
    //迪杰斯特拉算法

    /**
     * @param index 表示出发顶点对应的下标
     */
    public void dsj(int index) {
        vv = new VisitedVertex(vertex.length, index);//走完这步，说明从G(6)开始访问
        update(index);//更新index顶点到周围顶点的距离和前驱顶点（已更新两个数组，还剩一个）

        for (int j = 1; j < vertex.length; j++) {
            index = vv.updateArr();//选择并返回新的访问顶点（在这里更新第三个数组）
            update(index);
        }
    }

    //更新index下标顶点到周围顶点的距离和周围顶点的前驱顶点
    private void update(int index) {
        int len = 0;
        for (int i = 0; i < matrix.length; i++) {
            //len的含义：出发顶点到index顶点的距离 + 从index顶点到顶点i的距离之和
            len = vv.getDis(index) + matrix[index][i];
            //如果i顶点没有被访问过（!false），并且len小于出发顶点到i顶点的距离，就需要更新
            if (!vv.in(i) && len < vv.getDis(i)) {
                vv.updatePre(i, index);//更新i这个顶点的前驱为index
                vv.updateDis(i, len);//更新出发顶点到i顶点的距离;
            }
        }
    }
}

//已访问顶点的集合
class VisitedVertex {
    //记录各个顶点是否访问过 1表示访问过，0表示未访问，会动态更新
    public int[] already_arr;
    //每个下标对应的值为前一个顶点下标，会动态更新
    public int[] pre_visited;
    //记录出发顶点到其他所有顶点的距离，比如G为出发顶点，就会记录G到其他顶点的距离，会动态更新，求的最短距离就会存放到dis
    public int[] dis;

    /**
     * @param length 表示顶点的个数 初试length = 7
     * @param index  出发顶点的下标，比如G顶点，就是index = 6
     */
    public VisitedVertex(int length, int index) {
        this.already_arr = new int[length];
        this.pre_visited = new int[length];
        this.dis = new int[length];
        //初始化dis数组
        Arrays.fill(dis, 65535);
        this.already_arr[index] = 1;
        this.dis[index] = 0;//设置出发顶点的访问距离为0
    }

    /**
     * 功能：判断index顶点是否被访问过
     *
     * @param index
     * @return 如果访问过，就返回true，如果没有访问过返回false
     */
    public boolean in(int index) {
        return already_arr[index] == 1;
    }

    /**
     * 功能，更新出发顶点到index顶点的距离
     *
     * @param index 更新哪一个
     * @param len   距离
     */
    public void updateDis(int index, int len) {
        dis[index] = len;
    }

    /**
     * 功能：更新pre这个顶点的前驱为index顶点
     *
     * @param pre
     * @param index
     */
    public void updatePre(int pre, int index) {
        pre_visited[pre] = index;
    }

    /**
     * 功能：返回出发顶点到index顶点的距离
     *
     * @param index
     */
    public int getDis(int index) {
        return dis[index];
    }

    //继续选择并返回新的访问顶点，比如这里G访问完之后，就是A点作为新的访问顶点（注意不是出发顶点）
    public int updateArr() {
        int min = 65535, index = 0;
        for (int i = 0; i < already_arr.length; i++) {//从访问结点数组中找到还没访问过，同时从出发顶点到这个顶点距离最小的那个
            if (already_arr[i] == 0 && dis[i] < min) {
                min = dis[i];
                index = i;
            }
        }
        already_arr[index] = 1;
        return index;
    }

    //显示最后的结果
    //即将三个数组输出
    public void show() {
        System.out.println("======================");
        //输入alread_arr
        for (int i : already_arr) {
            System.out.print(i + " ");
        }
        System.out.println();

        System.out.println("======================");
        //输入pre_visited
        for (int i : pre_visited) {
            System.out.print(i + " ");
        }
        System.out.println();

        System.out.println("======================");
        //输入alread_arr
        for (int i : dis) {
            System.out.print(i + " ");
        }
        System.out.println();
        //为了好看最后的最短距离
        char[] vertex = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        int count = 0;
        for (int i : dis) {
            if (i != 65535) {
                System.out.print(vertex[count] + "(" + i + ")");
            }else {
                System.out.println("N ");
            }
            count++;
        }
        System.out.println();
    }
}
```





#### 弗洛伊德(Floyd)算法

应用场景：寻找给定的加权图中顶点间最短路径的算法。

1. 弗洛伊德算法计算图中各个顶点之间的最短路径
2. 迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径
3. **弗洛伊德算法VS迪杰斯特拉算法：**迪杰斯特拉散发通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每个顶点都是出发访问顶点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。



**算法分析**

1. 设置顶点vi到顶点vk的最短路径已知为Lik 顶点vk 到vj的最短路径为Lkj 顶点vi到vj的路径Lij，则vi到vj的最短路径为 min{(Lij + Lkj,Lij)},vk的取值为图中所有顶点，则可获得vi到vj的最短距离
2. 至于vi到vk的最短路径Lik或者vk到vj的最短路径Lkj,是以同样的方式获得

![image-20210819150054858](/Users/mac/Library/Application Support/typora-user-images/image-20210819150054858.png)

将A作为中间顶点的情况：

1. C-A-B[9]
2. C-A-G[12]
3. G-A-B[7]



![image-20210819150848862](/Users/mac/Library/Application Support/typora-user-images/image-20210819150848862.png)

就是三层for循环，时间复杂度很高O(n3)



```java
package com.hjfstudy.algorithom;

import java.util.Arrays;

public class FloydAlgorithm {
    public static void main(String[] args) {
        char[] vertex = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        int[][] matrix = new int[vertex.length][vertex.length];
        final int N = 65535;
        matrix = new int[][]{
                {0, 5, 7, N, N, N, 2},
                {5, 0, N, 9, N, N, 3},
                {7, N, 0, N, 8, N, N},
                {N, 9, N, 0, N, 4, N},
                {N, N, 8, N, 0, 5, 4},
                {N, N, N, 4, 5, 0, 6},
                {2, 3, N, N, 4, 6, 0}
        };

        //创建图对象
        FGraph graph = new FGraph(vertex.length, matrix, vertex);
        graph.show();
        graph.floyd();
        graph.show();
    }
}

//创建图
class FGraph {
    private char[] vertex;//存放顶点数组
    private int[][] dis;//保存从各个顶点出发到其他顶点的距离，最后的结果也保留在该数组中
    private int[][] pre;//保存到达目标顶点的前驱顶点

    //构造器
    public FGraph(int length, int[][] matrix, char[] vertex) {
        this.vertex = vertex;
        this.dis = matrix;
        this.pre = new int[length][length];

        //对pre数组初始化，存放的是前驱顶点的下标
        for (int i = 0; i < length; i++) {
            Arrays.fill(pre[i], i);
        }
    }

    //显示pre数组
    public void show() {

        char[] vertex = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        for (int i = 0; i < dis.length; i++) {
            //先将pre数组输出的一行
            for (int j = 0; j < dis.length; j++) {
                System.out.print(vertex[pre[i][j]] + " ");
            }
            System.out.println();
            //输出dis数组的一行数据
            for (int j = 0; j < dis.length; j++) {
                System.out.print("(" + vertex[i] + "到" + vertex[i] + "的最短路径为" + dis[i][j] + ")");
            }
            System.out.println();
            System.out.println();
        }
    }

    //弗洛伊德算法开始
    public void floyd(){
        int len = 0;//遍历保存距离
        //对中间定点遍历，k就是中间顶点的下标['A', 'B', 'C', 'D', 'E', 'F', 'G']
        for (int k = 0; k < dis.length; k++) {
            //从i顶点开始出发['A', 'B', 'C', 'D', 'E', 'F', 'G']
            for (int i = 0; i < dis.length; i++) {
                //到达J这个顶点
                for (int j = 0; j < dis.length; j++) {
                    len= dis[i][k] + dis[k][j];//求持股从i出发到k，再从k到j顶点的距离
                    if (len < dis[i][j]){//如果len小于直连的距离，那么就更新
                        dis[i][j] = len;
                        pre[i][j] = pre[k][j];//更新前驱节点

                    }
                }
            }
        }
    }

}
```







#### 马踏棋盘算法-骑士周游问题

![image-20210819153727080](/Users/mac/Library/Application Support/typora-user-images/image-20210819153727080.png)



实际上是图的深度优先（DFS）的应用





```java
package com.hjfstudy.algorithom;

import java.awt.*;
import java.lang.reflect.Array;
import java.util.ArrayList;

public class HorseChessboard {
    private static int X;//棋盘的列数
    private static int Y;//棋盘的行数
    //创建一个数组来标记棋盘的各个位置是否被访问过
    private static boolean[] visited;
    //使用一盒属性，标记是否棋盘的所有位置都被访问
    private static boolean finished;

    public static void main(String[] args) {
        //测试
        X = 8;
        Y = 8;
        int row = 1;//马儿初始位置的行
        int column = 1;//马儿初试位置的列
        //创建棋盘
        int[][] chessboard = new int[X][Y];
        visited = new boolean[X * Y];//初始值都是false

        //测试一下耗时
        long start = System.currentTimeMillis();
        traversalChessboard(chessboard, row - 1, column - 1, 1);
        long end = System.currentTimeMillis();
        System.out.println("共耗时：" + (end - start) + "毫秒");

        //输出棋盘的最后情况
        for (int[] rows : chessboard) {
            for (int step : rows) {
                System.out.print(step + "\t");
            }
            System.out.println();
        }

    }

    /**
     * 完成骑士周游问题的算法
     *
     * @param chessboard 棋盘
     * @param row        马儿当前的位置的行 从 0 开始
     * @param column     马儿当前位置的列 从 0 开始
     * @param step       第几步，初始位置就是第1步
     */
    public static void traversalChessboard(int[][] chessboard, int row, int column, int step) {
        chessboard[row][column] = step;
        //row = 4 X = 8 column = 4 ---->4 * 8 + 4 = 36
        visited[row * X + column] = true;//标记该位置已经访问
        //获取当前位置可以走的下一个位置的集合
        ArrayList<Point> ps = next(new Point(column, row));
      
      //对ps进行排序，排序的规则就是对ps的所有的Point对象的下一步的位置的数目，进行非递减排序
        sort(ps);
      
      
        //遍历ps
        while (!ps.isEmpty()) {
            Point p = ps.remove(0);
            if (!visited[p.y * X + p.x]) {//说明没有访问过
                traversalChessboard(chessboard, p.y, p.x, step + 1);
            }
        }
        //判断马儿是否完成任务，如果没有完成任务 将棋盘置零
        //1、棋盘到目前位置，没有走完
        //2、棋盘处于宇哥回溯过程
        if (step < X * Y && !finished) {
            chessboard[row][column] = 0;
            visited[row * X + column] = false;
        } else {
            finished = true;
        }
    }

    /**
     * 功能：根据当前位置（Point对象），计算马儿还能走哪些位置（Point）
     * 并放入到一个集合中（ArrayList）,最多有8个位置
     *
     * @param curPoint
     * @return
     */
    public static ArrayList<Point> next(Point curPoint) {
        //创建一个Arraylist
        ArrayList<Point> ps = new ArrayList<>();
        //创建一个Point
        Point p1 = new Point();
        //表示马儿可以往左走两列，往上走一列 5
        if ((p1.x = curPoint.x - 2) >= 0 && (p1.y = curPoint.y - 1) >= 0) {
            ps.add(new Point(p1));
        }
        //6
        if ((p1.x = curPoint.x - 1) >= 0 && (p1.y = curPoint.y - 2) >= 0) {
            ps.add(new Point(p1));
        }
        //7
        if ((p1.x = curPoint.x + 1) < X && (p1.y = curPoint.y - 2) >= 0) {
            ps.add(new Point(p1));
        }
        //0
        if ((p1.x = curPoint.x + 2) < X && (p1.y = curPoint.y - 1) >= 0) {
            ps.add(new Point(p1));
        }
        //1
        if ((p1.x = curPoint.x + 2) < X && (p1.y = curPoint.y + 1) < Y) {
            ps.add(new Point(p1));
        }
        //2
        if ((p1.x = curPoint.x + 1) < X && (p1.y = curPoint.y + 2) < Y) {
            ps.add(new Point(p1));
        }
        //3
        if ((p1.x = curPoint.x - 1) >= 0 && (p1.y = curPoint.y + 2) < Y) {
            ps.add(new Point(p1));
        }
        //走4
        if ((p1.x = curPoint.x - 2) >= 0 && (p1.y = curPoint.y + 1) < Y) {
            ps.add(new Point(p1));
        }

        return ps;
    }

}
```

![image-20210819164955178](/Users/mac/Library/Application Support/typora-user-images/image-20210819164955178.png)

![image-20210819164931354](/Users/mac/Library/Application Support/typora-user-images/image-20210819164931354.png)

```java
//根据当前这一步的所有下一步的选择位置，进行非递减排序
public static void  sort(ArrayList<Point> ps){
    ps.sort(new Comparator<Point>() {
        @Override
        public int compare(Point o1, Point o2) {
            //获取o1的下一步的所有位置个数
            int count1 = next(o1).size();
            int count2 = next(o2).size();
            if (count1 < count2){
                return -1;
            }else if(count1 == count2){
                return 0;
            }else {
                return 1;
            }
        }
    });
}
```

